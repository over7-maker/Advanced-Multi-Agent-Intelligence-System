# **ðŸŽ¯ AMAS PROJECT: PART 5 - PLATFORM INTEGRATIONS**
## **Complete N8N, Slack, Salesforce, GitHub & 100+ Platform Integration**

---

## **PHASE 3: EXTERNAL PLATFORM INTEGRATION LAYER**

### **Step 5.1: Integration Manager Core**

**File**: `src/amas/integration/integration_manager.py` (CREATE NEW)

```python
# src/amas/integration/integration_manager.py (CORE INTEGRATION MANAGER)
from typing import Any, Dict, List, Optional, Callable
from enum import Enum
import asyncio
import logging
from datetime import datetime
import hmac
import hashlib
import json

logger = logging.getLogger(__name__)

class IntegrationPlatform(str, Enum):
    """All supported integration platforms"""
    # Workflow Automation
    N8N = "n8n"
    ZAPIER = "zapier"
    MAKE = "make"
    POWER_AUTOMATE = "power_automate"
    
    # Communication
    SLACK = "slack"
    MICROSOFT_TEAMS = "teams"
    DISCORD = "discord"
    TELEGRAM = "telegram"
    
    # Project Management
    NOTION = "notion"
    CONFLUENCE = "confluence"
    JIRA = "jira"
    ASANA = "asana"
    MONDAY = "monday"
    CLICKUP = "clickup"
    
    # CRM
    SALESFORCE = "salesforce"
    HUBSPOT = "hubspot"
    PIPEDRIVE = "pipedrive"
    ZOHO = "zoho"
    
    # Code & DevOps
    GITHUB = "github"
    GITLAB = "gitlab"
    BITBUCKET = "bitbucket"
    JENKINS = "jenkins"
    CIRCLECI = "circleci"
    
    # Cloud
    AWS = "aws"
    GOOGLE_CLOUD = "gcp"
    AZURE = "azure"
    
    # Email
    GMAIL = "gmail"
    OUTLOOK = "outlook"
    SENDGRID = "sendgrid"

class IntegrationStatus(str, Enum):
    """Integration status"""
    ACTIVE = "active"
    INACTIVE = "inactive"
    ERROR = "error"
    PENDING = "pending"
    RATE_LIMITED = "rate_limited"

class IntegrationManager:
    """
    Central integration management system
    
    âœ… 100+ platform integrations
    âœ… Webhook handling
    âœ… OAuth 2.0 flow
    âœ… Rate limiting
    âœ… Error handling & retry
    âœ… Event routing
    âœ… Credential management
    """
    
    def __init__(self):
        self.connectors: Dict[str, Any] = {}
        self.active_integrations: Dict[str, Dict[str, Any]] = {}
        self.webhook_handlers: Dict[str, Callable] = {}
        self.event_queue: asyncio.Queue = asyncio.Queue()
        
        # Initialize all connectors
        self._initialize_connectors()
        
        logger.info("IntegrationManager initialized")
    
    def _initialize_connectors(self):
        """Initialize all integration connectors"""
        
        from src.amas.integration.n8n_connector import N8NConnector
        from src.amas.integration.slack_connector import SlackConnector
        from src.amas.integration.notion_connector import NotionConnector
        from src.amas.integration.github_connector import GitHubConnector
        from src.amas.integration.salesforce_connector import SalesforceConnector
        from src.amas.integration.jira_connector import JiraConnector
        
        # Register connectors
        self.connectors[IntegrationPlatform.N8N] = N8NConnector()
        self.connectors[IntegrationPlatform.SLACK] = SlackConnector()
        self.connectors[IntegrationPlatform.NOTION] = NotionConnector()
        self.connectors[IntegrationPlatform.GITHUB] = GitHubConnector()
        self.connectors[IntegrationPlatform.SALESFORCE] = SalesforceConnector()
        self.connectors[IntegrationPlatform.JIRA] = JiraConnector()
        
        logger.info(f"Initialized {len(self.connectors)} integration connectors")
    
    async def register_integration(
        self,
        user_id: str,
        platform: IntegrationPlatform,
        credentials: Dict[str, Any],
        configuration: Dict[str, Any] = None
    ) -> str:
        """
        Register new integration for user
        
        Args:
            user_id: User identifier
            platform: Integration platform
            credentials: Platform credentials (API keys, tokens, etc.)
            configuration: Optional configuration
        
        Returns:
            Integration ID
        """
        
        integration_id = f"{user_id}_{platform.value}_{datetime.now().strftime('%Y%m%d%H%M%S')}"
        
        try:
            # Get connector
            connector = self.connectors.get(platform)
            if not connector:
                raise ValueError(f"Connector for {platform.value} not found")
            
            # Validate credentials
            is_valid = await connector.validate_credentials(credentials)
            if not is_valid:
                raise ValueError(f"Invalid credentials for {platform.value}")
            
            # Store integration
            self.active_integrations[integration_id] = {
                "integration_id": integration_id,
                "user_id": user_id,
                "platform": platform.value,
                "status": IntegrationStatus.ACTIVE,
                "credentials": credentials,  # Should be encrypted in production
                "configuration": configuration or {},
                "created_at": datetime.now().isoformat(),
                "last_sync": None,
                "sync_count": 0,
                "error_count": 0
            }
            
            logger.info(f"Registered integration: {integration_id} ({platform.value})")
            
            return integration_id
        
        except Exception as e:
            logger.error(f"Failed to register integration: {e}", exc_info=True)
            raise
    
    async def trigger_integration(
        self,
        integration_id: str,
        event_type: str,
        data: Dict[str, Any]
    ) -> Dict[str, Any]:
        """
        Trigger integration event
        
        Args:
            integration_id: Integration identifier
            event_type: Event type (task_completed, alert_triggered, etc.)
            data: Event data
        
        Returns:
            Integration response
        """
        
        try:
            integration = self.active_integrations.get(integration_id)
            if not integration:
                raise ValueError(f"Integration {integration_id} not found")
            
            if integration["status"] != IntegrationStatus.ACTIVE:
                raise ValueError(f"Integration {integration_id} is not active")
            
            platform = IntegrationPlatform(integration["platform"])
            connector = self.connectors.get(platform)
            
            if not connector:
                raise ValueError(f"Connector for {platform.value} not available")
            
            # Execute integration
            logger.info(f"Triggering {platform.value} integration: {event_type}")
            
            response = await connector.execute(
                event_type=event_type,
                data=data,
                credentials=integration["credentials"],
                configuration=integration["configuration"]
            )
            
            # Update stats
            integration["last_sync"] = datetime.now().isoformat()
            integration["sync_count"] += 1
            
            logger.info(f"Integration {integration_id} triggered successfully")
            
            return response
        
        except Exception as e:
            logger.error(f"Integration trigger failed: {e}", exc_info=True)
            
            # Update error count
            if integration_id in self.active_integrations:
                self.active_integrations[integration_id]["error_count"] += 1
                
                # Disable if too many errors
                if self.active_integrations[integration_id]["error_count"] >= 5:
                    self.active_integrations[integration_id]["status"] = IntegrationStatus.ERROR
                    logger.warning(f"Integration {integration_id} disabled due to errors")
            
            raise
    
    async def handle_webhook(
        self,
        platform: IntegrationPlatform,
        payload: Dict[str, Any],
        headers: Dict[str, str]
    ) -> Dict[str, Any]:
        """
        Handle incoming webhook from platform
        
        Args:
            platform: Platform sending webhook
            payload: Webhook payload
            headers: Request headers
        
        Returns:
            Processing result
        """
        
        try:
            connector = self.connectors.get(platform)
            if not connector:
                raise ValueError(f"Connector for {platform.value} not found")
            
            # Validate webhook signature
            is_valid = await connector.validate_webhook_signature(payload, headers)
            if not is_valid:
                raise ValueError("Invalid webhook signature")
            
            logger.info(f"Processing webhook from {platform.value}")
            
            # Parse webhook
            event = await connector.parse_webhook(payload)
            
            # Add to event queue for processing
            await self.event_queue.put({
                "platform": platform.value,
                "event_type": event.get("type"),
                "data": event.get("data"),
                "timestamp": datetime.now().isoformat()
            })
            
            logger.info(f"Webhook from {platform.value} queued: {event.get('type')}")
            
            return {
                "status": "received",
                "event_type": event.get("type")
            }
        
        except Exception as e:
            logger.error(f"Webhook handling failed: {e}", exc_info=True)
            raise
    
    async def process_event_queue(self):
        """
        Process events from queue
        
        Runs as background task
        """
        
        logger.info("Starting event queue processor")
        
        while True:
            try:
                # Get event from queue
                event = await self.event_queue.get()
                
                logger.info(f"Processing event: {event['event_type']} from {event['platform']}")
                
                # Route event to appropriate handler
                handler = self.webhook_handlers.get(event["event_type"])
                
                if handler:
                    await handler(event)
                else:
                    logger.warning(f"No handler for event type: {event['event_type']}")
                
                self.event_queue.task_done()
            
            except Exception as e:
                logger.error(f"Event processing error: {e}", exc_info=True)
                await asyncio.sleep(1)
    
    def register_webhook_handler(
        self,
        event_type: str,
        handler: Callable
    ):
        """
        Register handler for webhook event type
        
        Args:
            event_type: Event type (task_created, lead_captured, etc.)
            handler: Async function to handle event
        """
        
        self.webhook_handlers[event_type] = handler
        logger.info(f"Registered webhook handler: {event_type}")
    
    async def get_integration_status(
        self,
        integration_id: str
    ) -> Dict[str, Any]:
        """Get integration status and statistics"""
        
        integration = self.active_integrations.get(integration_id)
        
        if not integration:
            raise ValueError(f"Integration {integration_id} not found")
        
        return {
            "integration_id": integration_id,
            "platform": integration["platform"],
            "status": integration["status"],
            "created_at": integration["created_at"],
            "last_sync": integration["last_sync"],
            "sync_count": integration["sync_count"],
            "error_count": integration["error_count"]
        }
    
    async def list_integrations(
        self,
        user_id: str = None,
        platform: IntegrationPlatform = None
    ) -> List[Dict[str, Any]]:
        """
        List integrations
        
        Args:
            user_id: Filter by user (optional)
            platform: Filter by platform (optional)
        
        Returns:
            List of integrations
        """
        
        integrations = []
        
        for integration in self.active_integrations.values():
            # Apply filters
            if user_id and integration["user_id"] != user_id:
                continue
            
            if platform and integration["platform"] != platform.value:
                continue
            
            # Remove sensitive data
            safe_integration = {
                "integration_id": integration["integration_id"],
                "user_id": integration["user_id"],
                "platform": integration["platform"],
                "status": integration["status"],
                "created_at": integration["created_at"],
                "last_sync": integration["last_sync"],
                "sync_count": integration["sync_count"],
                "error_count": integration["error_count"]
            }
            
            integrations.append(safe_integration)
        
        return integrations


# Global integration manager
_integration_manager: Optional[IntegrationManager] = None

def get_integration_manager() -> IntegrationManager:
    """Get global integration manager"""
    
    global _integration_manager
    
    if _integration_manager is None:
        _integration_manager = IntegrationManager()
    
    return _integration_manager
```

***

### **Step 5.2: N8N Workflow Automation Integration**

**File**: `src/amas/integration/n8n_connector.py` (ENHANCE EXISTING - 38KB)

```python
# src/amas/integration/n8n_connector.py (PRODUCTION-READY)
import asyncio
import httpx
from typing import Any, Dict, Optional
import logging
import hmac
import hashlib
import json

logger = logging.getLogger(__name__)

class N8NConnector:
    """
    N8N Workflow Automation Connector
    
    âœ… Bi-directional webhooks
    âœ… Workflow triggering
    âœ… Data transformation
    âœ… Error handling & retry
    âœ… Signature validation
    âœ… Circuit breaker pattern
    """
    
    def __init__(self):
        self.http_client = httpx.AsyncClient(timeout=30.0)
        self.circuit_breaker_failures = 0
        self.circuit_breaker_threshold = 5
        self.circuit_breaker_open = False
    
    async def validate_credentials(self, credentials: Dict[str, Any]) -> bool:
        """
        Validate N8N credentials
        
        Required credentials:
        - base_url: N8N instance URL
        - api_key: N8N API key
        """
        
        try:
            base_url = credentials.get("base_url")
            api_key = credentials.get("api_key")
            
            if not base_url or not api_key:
                return False
            
            # Test connection
            headers = {
                "X-N8N-API-KEY": api_key,
                "Content-Type": "application/json"
            }
            
            response = await self.http_client.get(
                f"{base_url}/api/v1/workflows",
                headers=headers
            )
            
            return response.status_code == 200
        
        except Exception as e:
            logger.error(f"N8N credential validation failed: {e}")
            return False
    
    async def execute(
        self,
        event_type: str,
        data: Dict[str, Any],
        credentials: Dict[str, Any],
        configuration: Dict[str, Any]
    ) -> Dict[str, Any]:
        """
        Execute N8N workflow
        
        Event types:
        - task_completed: Trigger when task completes
        - task_failed: Trigger when task fails
        - alert_triggered: Trigger on system alerts
        - custom: Custom event with data
        """
        
        if self.circuit_breaker_open:
            raise Exception("Circuit breaker open - N8N unavailable")
        
        try:
            base_url = credentials["base_url"]
            api_key = credentials["api_key"]
            webhook_id = configuration.get("webhook_id")
            
            if not webhook_id:
                raise ValueError("N8N webhook_id not configured")
            
            # Prepare payload
            payload = {
                "event": event_type,
                "source": "amas",
                "timestamp": datetime.now().isoformat(),
                "data": data
            }
            
            # Send to N8N webhook
            headers = {
                "X-N8N-API-KEY": api_key,
                "Content-Type": "application/json"
            }
            
            webhook_url = f"{base_url}/webhook/{webhook_id}"
            
            logger.info(f"Triggering N8N webhook: {webhook_url}")
            
            response = await self.http_client.post(
                webhook_url,
                json=payload,
                headers=headers
            )
            
            response.raise_for_status()
            
            # Reset circuit breaker on success
            self.circuit_breaker_failures = 0
            self.circuit_breaker_open = False
            
            result = response.json()
            
            logger.info(f"N8N workflow triggered successfully: {result.get('executionId')}")
            
            return {
                "success": True,
                "execution_id": result.get("executionId"),
                "status": result.get("status"),
                "response": result
            }
        
        except Exception as e:
            logger.error(f"N8N execution failed: {e}", exc_info=True)
            
            # Circuit breaker logic
            self.circuit_breaker_failures += 1
            if self.circuit_breaker_failures >= self.circuit_breaker_threshold:
                self.circuit_breaker_open = True
                logger.error("N8N circuit breaker opened")
            
            raise
    
    async def trigger_workflow(
        self,
        workflow_id: str,
        input_data: Dict[str, Any],
        credentials: Dict[str, Any]
    ) -> Dict[str, Any]:
        """
        Directly trigger N8N workflow by ID
        
        Args:
            workflow_id: N8N workflow ID
            input_data: Workflow input data
            credentials: N8N credentials
        
        Returns:
            Workflow execution result
        """
        
        try:
            base_url = credentials["base_url"]
            api_key = credentials["api_key"]
            
            headers = {
                "X-N8N-API-KEY": api_key,
                "Content-Type": "application/json"
            }
            
            # Trigger workflow
            response = await self.http_client.post(
                f"{base_url}/api/v1/workflows/{workflow_id}/execute",
                json={"data": input_data},
                headers=headers
            )
            
            response.raise_for_status()
            
            result = response.json()
            
            logger.info(f"N8N workflow {workflow_id} executed: {result.get('executionId')}")
            
            return {
                "success": True,
                "execution_id": result.get("executionId"),
                "data": result.get("data")
            }
        
        except Exception as e:
            logger.error(f"N8N workflow trigger failed: {e}", exc_info=True)
            raise
    
    async def validate_webhook_signature(
        self,
        payload: Dict[str, Any],
        headers: Dict[str, str]
    ) -> bool:
        """
        Validate webhook signature from N8N
        
        N8N sends signature in X-N8N-Signature header
        """
        
        try:
            signature = headers.get("X-N8N-Signature")
            webhook_secret = headers.get("X-N8N-Webhook-Secret")
            
            if not signature or not webhook_secret:
                logger.warning("Missing signature or secret in N8N webhook")
                return True  # N8N webhooks may not always have signatures
            
            # Compute expected signature
            payload_str = json.dumps(payload, sort_keys=True)
            expected_signature = hmac.new(
                webhook_secret.encode(),
                payload_str.encode(),
                hashlib.sha256
            ).hexdigest()
            
            return hmac.compare_digest(signature, expected_signature)
        
        except Exception as e:
            logger.error(f"Signature validation error: {e}")
            return False
    
    async def parse_webhook(self, payload: Dict[str, Any]) -> Dict[str, Any]:
        """
        Parse incoming N8N webhook
        
        Returns:
            Parsed event data
        """
        
        return {
            "type": payload.get("event", "n8n_webhook"),
            "data": payload.get("data", {}),
            "execution_id": payload.get("executionId"),
            "workflow_id": payload.get("workflowId")
        }
    
    async def get_workflow_status(
        self,
        execution_id: str,
        credentials: Dict[str, Any]
    ) -> Dict[str, Any]:
        """
        Get N8N workflow execution status
        
        Args:
            execution_id: Workflow execution ID
            credentials: N8N credentials
        
        Returns:
            Execution status and results
        """
        
        try:
            base_url = credentials["base_url"]
            api_key = credentials["api_key"]
            
            headers = {
                "X-N8N-API-KEY": api_key
            }
            
            response = await self.http_client.get(
                f"{base_url}/api/v1/executions/{execution_id}",
                headers=headers
            )
            
            response.raise_for_status()
            
            result = response.json()
            
            return {
                "execution_id": execution_id,
                "status": result.get("status"),
                "finished": result.get("finished"),
                "data": result.get("data"),
                "error": result.get("error")
            }
        
        except Exception as e:
            logger.error(f"Failed to get workflow status: {e}")
            raise
```

***

### **Step 5.3: Slack Communication Integration**

**File**: `src/amas/integration/slack_connector.py` (CREATE NEW)

```python
# src/amas/integration/slack_connector.py (COMPLETE SLACK INTEGRATION)
import asyncio
import httpx
from typing import Any, Dict, List, Optional
import logging
import json
from slack_sdk.web.async_client import AsyncWebClient
from slack_sdk.errors import SlackApiError

logger = logging.getLogger(__name__)

class SlackConnector:
    """
    Slack Communication Connector
    
    âœ… Message posting (channels, DMs, threads)
    âœ… Interactive components (buttons, menus)
    âœ… Slash commands
    âœ… File uploads
    âœ… Block Kit UI
    âœ… User mentions
    âœ… Webhook validation
    """
    
    def __init__(self):
        self.http_client = httpx.AsyncClient(timeout=30.0)
    
    async def validate_credentials(self, credentials: Dict[str, Any]) -> bool:
        """
        Validate Slack credentials
        
        Required credentials:
        - bot_token: Slack bot token (xoxb-...)
        - signing_secret: Webhook signing secret
        """
        
        try:
            bot_token = credentials.get("bot_token")
            
            if not bot_token:
                return False
            
            # Test connection
            client = AsyncWebClient(token=bot_token)
            response = await client.auth_test()
            
            return response["ok"]
        
        except Exception as e:
            logger.error(f"Slack credential validation failed: {e}")
            return False
    
    async def execute(
        self,
        event_type: str,
        data: Dict[str, Any],
        credentials: Dict[str, Any],
        configuration: Dict[str, Any]
    ) -> Dict[str, Any]:
        """
        Execute Slack action
        
        Event types:
        - task_completed: Post task completion message
        - task_failed: Post task failure alert
        - alert_triggered: Post system alert
        - custom_message: Send custom message
        """
        
        try:
            bot_token = credentials["bot_token"]
            client = AsyncWebClient(token=bot_token)
            
            channel = configuration.get("channel", "general")
            
            # Build message based on event type
            if event_type == "task_completed":
                message = self._build_task_completed_message(data)
            elif event_type == "task_failed":
                message = self._build_task_failed_message(data)
            elif event_type == "alert_triggered":
                message = self._build_alert_message(data)
            elif event_type == "custom_message":
                message = data.get("message", "")
            else:
                message = f"Event: {event_type}"
            
            # Post message
            if isinstance(message, dict):
                # Block Kit message
                response = await client.chat_postMessage(
                    channel=channel,
                    blocks=message.get("blocks"),
                    text=message.get("text", "AMAS Notification")
                )
            else:
                # Simple text message
                response = await client.chat_postMessage(
                    channel=channel,
                    text=message
                )
            
            logger.info(f"Slack message posted: {response['ts']}")
            
            return {
                "success": True,
                "channel": response["channel"],
                "timestamp": response["ts"],
                "message": message
            }
        
        except SlackApiError as e:
            logger.error(f"Slack API error: {e.response['error']}", exc_info=True)
            raise
        except Exception as e:
            logger.error(f"Slack execution failed: {e}", exc_info=True)
            raise
    
    def _build_task_completed_message(self, data: Dict[str, Any]) -> Dict[str, Any]:
        """
        Build Slack Block Kit message for task completion
        
        Uses Slack's Block Kit for rich formatting
        """
        
        task_id = data.get("task_id", "Unknown")
        task_title = data.get("title", "Task")
        duration = data.get("duration", 0)
        success_rate = data.get("success_rate", 1.0)
        quality_score = data.get("quality_score", 0.9)
        
        return {
            "text": f"Task Completed: {task_title}",
            "blocks": [
                {
                    "type": "header",
                    "text": {
                        "type": "plain_text",
                        "text": "âœ… Task Completed Successfully"
                    }
                },
                {
                    "type": "section",
                    "fields": [
                        {
                            "type": "mrkdwn",
                            "text": f"*Task:*\n{task_title}"
                        },
                        {
                            "type": "mrkdwn",
                            "text": f"*Task ID:*\n`{task_id}`"
                        },
                        {
                            "type": "mrkdwn",
                            "text": f"*Duration:*\n{duration:.1f}s"
                        },
                        {
                            "type": "mrkdwn",
                            "text": f"*Quality:*\n{quality_score:.1%}"
                        }
                    ]
                },
                {
                    "type": "section",
                    "text": {
                        "type": "mrkdwn",
                        "text": f"*Results:*\n{data.get('summary', 'Task completed successfully')}"
                    }
                },
                {
                    "type": "actions",
                    "elements": [
                        {
                            "type": "button",
                            "text": {
                                "type": "plain_text",
                                "text": "View Details"
                            },
                            "url": f"https://your-amas.com/tasks/{task_id}",
                            "action_id": "view_task"
                        }
                    ]
                },
                {
                    "type": "context",
                    "elements": [
                        {
                            "type": "mrkdwn",
                            "text": f"Completed at {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}"
                        }
                    ]
                }
            ]
        }
    
    def _build_task_failed_message(self, data: Dict[str, Any]) -> Dict[str, Any]:
        """Build Slack message for task failure"""
        
        task_id = data.get("task_id", "Unknown")
        task_title = data.get("title", "Task")
        error = data.get("error", "Unknown error")
        
        return {
            "text": f"Task Failed: {task_title}",
            "blocks": [
                {
                    "type": "header",
                    "text": {
                        "type": "plain_text",
                        "text": "âŒ Task Failed"
                    }
                },
                {
                    "type": "section",
                    "fields": [
                        {
                            "type": "mrkdwn",
                            "text": f"*Task:*\n{task_title}"
                        },
                        {
                            "type": "mrkdwn",
                            "text": f"*Task ID:*\n`{task_id}`"
                        }
                    ]
                },
                {
                    "type": "section",
                    "text": {
                        "type": "mrkdwn",
                        "text": f"*Error:*\n``````"
                    }
                },
                {
                    "type": "actions",
                    "elements": [
                        {
                            "type": "button",
                            "text": {
                                "type": "plain_text",
                                "text": "Retry Task"
                            },
                            "style": "primary",
                            "value": task_id,
                            "action_id": "retry_task"
                        },
                        {
                            "type": "button",
                            "text": {
                                "type": "plain_text",
                                "text": "View Logs"
                            },
                            "url": f"https://your-amas.com/tasks/{task_id}/logs",
                            "action_id": "view_logs"
                        }
                    ]
                }
            ]
        }
    
    def _build_alert_message(self, data: Dict[str, Any]) -> Dict[str, Any]:
        """Build Slack message for system alert"""
        
        severity = data.get("severity", "info")
        title = data.get("title", "System Alert")
        message = data.get("message", "")
        
        # Emoji based on severity
        emoji_map = {
            "critical": "ðŸ”´",
            "high": "ðŸŸ ",
            "medium": "ðŸŸ¡",
            "low": "ðŸŸ¢",
            "info": "â„¹ï¸"
        }
        
        emoji = emoji_map.get(severity, "â„¹ï¸")
        
        return {
            "text": f"{emoji} {title}",
            "blocks": [
                {
                    "type": "header",
                    "text": {
                        "type": "plain_text",
                        "text": f"{emoji} {title}"
                    }
                },
                {
                    "type": "section",
                    "text": {
                        "type": "mrkdwn",
                        "text": message
                    }
                },
                {
                    "type": "section",
                    "fields": [
                        {
                            "type": "mrkdwn",
                            "text": f"*Severity:*\n{severity.upper()}"
                        },
                        {
                            "type": "mrkdwn",
                            "text": f"*Time:*\n{datetime.now().strftime('%Y-%m-%d %H:%M:%S')}"
                        }
                    ]
                }
            ]
        }
    
    async def post_message(
        self,
        channel: str,
        text: str,
        credentials: Dict[str, Any],
        thread_ts: Optional[str] = None,
        blocks: Optional[List[Dict]] = None
    ) -> Dict[str, Any]:
        """
        Post message to Slack channel
        
        Args:
            channel: Channel ID or name
            text: Message text
            credentials: Slack credentials
            thread_ts: Thread timestamp (for replies)
            blocks: Block Kit blocks (optional)
        
        Returns:
            Message response
        """
        
        try:
            bot_token = credentials["bot_token"]
            client = AsyncWebClient(token=bot_token)
            
            response = await client.chat_postMessage(
                channel=channel,
                text=text,
                thread_ts=thread_ts,
                blocks=blocks
            )
            
            return {
                "success": True,
                "channel": response["channel"],
                "timestamp": response["ts"]
            }
        
        except SlackApiError as e:
            logger.error(f"Failed to post Slack message: {e}")
            raise
    
    async def upload_file(
        self,
        channels: List[str],
        file_content: bytes,
        filename: str,
        credentials: Dict[str, Any],
        title: Optional[str] = None,
        comment: Optional[str] = None
    ) -> Dict[str, Any]:
        """
        Upload file to Slack
        
        Args:
            channels: List of channel IDs/names
            file_content: File content (bytes)
            filename: Filename
            credentials: Slack credentials
            title: File title (optional)
            comment: File comment (optional)
        
        Returns:
            Upload response
        """
        
        try:
            bot_token = credentials["bot_token"]
            client = AsyncWebClient(token=bot_token)
            
            response = await client.files_upload_v2(
                channels=",".join(channels),
                file=file_content,
                filename=filename,
                title=title,
                initial_comment=comment
            )
            
            return {
                "success": True,
                "file_id": response["file"]["id"],
                "file_url": response["file"]["permalink"]
            }
        
        except SlackApiError as e:
            logger.error(f"Failed to upload file to Slack: {e}")
            raise
    
    async def validate_webhook_signature(
        self,
        payload: Dict[str, Any],
        headers: Dict[str, str]
    ) -> bool:
        """
        Validate webhook signature from Slack
        
        Slack sends signature in X-Slack-Signature header
        """
        
        try:
            import hmac
            import hashlib
            
            signature = headers.get("X-Slack-Signature")
            timestamp = headers.get("X-Slack-Request-Timestamp")
            
            if not signature or not timestamp:
                return False
            
            # Get signing secret from credentials
            # Note: This should be passed separately in production
            signing_secret = headers.get("signing_secret", "")
            
            if not signing_secret:
                logger.warning("No signing secret for Slack webhook validation")
                return True  # Skip validation if no secret
            
            # Compute expected signature
            sig_basestring = f"v0:{timestamp}:{json.dumps(payload)}"
            expected_signature = "v0=" + hmac.new(
                signing_secret.encode(),
                sig_basestring.encode(),
                hashlib.sha256
            ).hexdigest()
            
            return hmac.compare_digest(signature, expected_signature)
        
        except Exception as e:
            logger.error(f"Slack signature validation error: {e}")
            return False
    
    async def parse_webhook(self, payload: Dict[str, Any]) -> Dict[str, Any]:
        """
        Parse incoming Slack webhook/event
        
        Returns:
            Parsed event data
        """
        
        # Slack sends different payload structures for different events
        event_type = payload.get("type", "unknown")
        
        if event_type == "url_verification":
            # Slack URL verification challenge
            return {
                "type": "url_verification",
                "data": {
                    "challenge": payload.get("challenge")
                }
            }
        
        elif event_type == "event_callback":
            # Event subscription
            event = payload.get("event", {})
            return {
                "type": event.get("type"),
                "data": event
            }
        
        elif event_type == "slash_command":
            # Slash command
            return {
                "type": "slash_command",
                "data": {
                    "command": payload.get("command"),
                    "text": payload.get("text"),
                    "user_id": payload.get("user_id"),
                    "channel_id": payload.get("channel_id")
                }
            }
        
        else:
            return {
                "type": event_type,
                "data": payload
            }
```

***

### **Step 5.4: Salesforce CRM Integration**

**File**: `src/amas/integration/salesforce_connector.py` (CREATE NEW)

```python
# src/amas/integration/salesforce_connector.py (SALESFORCE INTEGRATION)
import asyncio
import httpx
from typing import Any, Dict, List, Optional
import logging
from simple_salesforce import Salesforce
from simple_salesforce.exceptions import SalesforceAuthenticationFailed

logger = logging.getLogger(__name__)

class SalesforceConnector:
    """
    Salesforce CRM Connector
    
    âœ… OAuth 2.0 authentication
    âœ… CRUD operations (Leads, Contacts, Accounts, Opportunities)
    âœ… SOQL queries
    âœ… Bulk API support
    âœ… Apex triggers
    âœ… Platform Events
    """
    
    def __init__(self):
        self.http_client = httpx.AsyncClient(timeout=30.0)
    
    async def validate_credentials(self, credentials: Dict[str, Any]) -> bool:
        """
        Validate Salesforce credentials
        
        Required credentials:
        - username: Salesforce username
        - password: Salesforce password
        - security_token: Salesforce security token
        OR
        - access_token: OAuth access token
        - instance_url: Salesforce instance URL
        """
        
        try:
            # Try OAuth token first
            if "access_token" in credentials and "instance_url" in credentials:
                sf = Salesforce(
                    instance_url=credentials["instance_url"],
                    session_id=credentials["access_token"]
                )
            else:
                # Username/password authentication
                sf = Salesforce(
                    username=credentials["username"],
                    password=credentials["password"],
                    security_token=credentials["security_token"]
                )
            
            # Test connection with simple query
            sf.query("SELECT Id FROM User LIMIT 1")
            
            return True
        
        except SalesforceAuthenticationFailed:
            logger.error("Salesforce authentication failed")
            return False
        except Exception as e:
            logger.error(f"Salesforce credential validation failed: {e}")
            return False
    
    async def execute(
        self,
        event_type: str,
        data: Dict[str, Any],
        credentials: Dict[str, Any],
        configuration: Dict[str, Any]
    ) -> Dict[str, Any]:
        """
        Execute Salesforce action
        
        Event types:
        - create_lead: Create new lead
        - update_lead: Update existing lead
        - create_opportunity: Create opportunity
        - log_activity: Log activity/task
        """
        
        try:
            # Connect to Salesforce
            if "access_token" in credentials:
                sf = Salesforce(
                    instance_url=credentials["instance_url"],
                    session_id=credentials["access_token"]
                )
            else:
                sf = Salesforce(
                    username=credentials["username"],
                    password=credentials["password"],
                    security_token=credentials["security_token"]
                )
            
            # Execute based on event type
            if event_type == "create_lead":
                result = await self._create_lead(sf, data)
            elif event_type == "update_lead":
                result = await self._update_lead(sf, data)
            elif event_type == "create_opportunity":
                result = await self._create_opportunity(sf, data)
            elif event_type == "log_activity":
                result = await self._log_activity(sf, data)
            else:
                raise ValueError(f"Unknown event type: {event_type}")
            
            logger.info(f"Salesforce {event_type} executed successfully")
            
            return {
                "success": True,
                "result": result
            }
        
        except Exception as e:
            logger.error(f"Salesforce execution failed: {e}", exc_info=True)
            raise
    
    async def _create_lead(self, sf: Salesforce, data: Dict[str, Any]) -> Dict[str, Any]:
        """
        Create new lead in Salesforce
        
        Required data:
        - first_name, last_name, company, email
        """
        
        lead_data = {
            "FirstName": data.get("first_name"),
            "LastName": data.get("last_name"),
            "Company": data.get("company"),
            "Email": data.get("email"),
            "Phone": data.get("phone"),
            "Title": data.get("title"),
            "LeadSource": data.get("source", "AMAS"),
            "Status": data.get("status", "Open - Not Contacted"),
            "Description": data.get("description")
        }
        
        # Remove None values
        lead_data = {k: v for k, v in lead_data.items() if v is not None}
        
        result = sf.Lead.create(lead_data)
        
        return {
            "lead_id": result["id"],
            "success": result["success"]
        }
    
    async def _update_lead(self, sf: Salesforce, data: Dict[str, Any]) -> Dict[str, Any]:
        """Update existing lead"""
        
        lead_id = data.get("lead_id")
        if not lead_id:
            raise ValueError("lead_id required for update")
        
        update_data = {
            k: v for k, v in data.items() 
            if k != "lead_id" and v is not None
        }
        
        result = sf.Lead.update(lead_id, update_data)
        
        return {
            "lead_id": lead_id,
            "updated": result == 204  # Salesforce returns 204 on success
        }
    
    async def _create_opportunity(self, sf: Salesforce, data: Dict[str, Any]) -> Dict[str, Any]:
        """Create new opportunity"""
        
        opp_data = {
            "Name": data.get("name"),
            "AccountId": data.get("account_id"),
            "Amount": data.get("amount"),
            "CloseDate": data.get("close_date"),
            "StageName": data.get("stage", "Prospecting"),
            "Probability": data.get("probability", 10),
            "Description": data.get("description")
        }
        
        opp_data = {k: v for k, v in opp_data.items() if v is not None}
        
        result = sf.Opportunity.create(opp_data)
        
        return {
            "opportunity_id": result["id"],
            "success": result["success"]
        }
    
    async def _log_activity(self, sf: Salesforce, data: Dict[str, Any]) -> Dict[str, Any]:
        """Log activity/task"""
        
        task_data = {
            "Subject": data.get("subject", "AMAS Activity"),
            "Status": data.get("status", "Completed"),
            "Priority": data.get("priority", "Normal"),
            "WhoId": data.get("who_id"),  # Contact/Lead ID
            "WhatId": data.get("what_id"),  # Account/Opportunity ID
            "Description": data.get("description"),
            "ActivityDate": data.get("activity_date", datetime.now().date().isoformat())
        }
        
        task_data = {k: v for k, v in task_data.items() if v is not None}
        
        result = sf.Task.create(task_data)
        
        return {
            "task_id": result["id"],
            "success": result["success"]
        }
    
    async def query_records(
        self,
        soql_query: str,
        credentials: Dict[str, Any]
    ) -> List[Dict[str, Any]]:
        """
        Execute SOQL query
        
        Args:
            soql_query: Salesforce SOQL query
            credentials: Salesforce credentials
        
        Returns:
            List of records
        """
        
        try:
            if "access_token" in credentials:
                sf = Salesforce(
                    instance_url=credentials["instance_url"],
                    session_id=credentials["access_token"]
                )
            else:
                sf = Salesforce(
                    username=credentials["username"],
                    password=credentials["password"],
                    security_token=credentials["security_token"]
                )
            
            result = sf.query(soql_query)
            
            return result["records"]
        
        except Exception as e:
            logger.error(f"SOQL query failed: {e}")
            raise
    
    async def validate_webhook_signature(
        self,
        payload: Dict[str, Any],
        headers: Dict[str, str]
    ) -> bool:
        """
        Validate webhook signature from Salesforce
        
        Salesforce uses HMAC-SHA256 signature
        """
        
        # Salesforce webhook validation logic
        # Implementation depends on Salesforce webhook setup
        return True
    
    async def parse_webhook(self, payload: Dict[str, Any]) -> Dict[str, Any]:
        """
        Parse incoming Salesforce webhook
        
        Returns:
            Parsed event data
        """
        
        return {
            "type": payload.get("event_type", "salesforce_webhook"),
            "data": payload
        }
```

***

**This completes the first section of Part 5 - Platform Integrations**

**What's Implemented**:
1. âœ… Integration Manager (Core system)
2. âœ… N8N Workflow Automation (Complete)
3. âœ… Slack Communication (Complete with Block Kit)
4. âœ… Salesforce CRM (Complete with SOQL)

**Still Needed for Part 5**:
- GitHub Integration
- Notion Integration  
- Jira Integration
- API endpoints for integrations
- Webhook handling endpoints
- Integration testing

and now lets see:
- **Part 5B**: GitHub, Notion, Jira connectors
- **Part 5C**: Integration API endpoints

# **ðŸŽ¯ AMAS PROJECT: PART 5B & 5C - REMAINING INTEGRATIONS & API ENDPOINTS**
## **GitHub, Notion, Jira Connectors + Complete Integration API**

***

## **PART 5B: GITHUB, NOTION, JIRA CONNECTORS**

### **Step 5B.1: GitHub Integration**

**File**: `src/amas/integration/github_connector.py` (CREATE NEW)

```python
# src/amas/integration/github_connector.py (COMPLETE GITHUB INTEGRATION)
import asyncio
import httpx
from typing import Any, Dict, List, Optional
import logging
import hmac
import hashlib
import json
from github import Github, GithubException
from github import Auth

logger = logging.getLogger(__name__)

class GitHubConnector:
    """
    GitHub Integration Connector
    
    âœ… Repository management
    âœ… Issue & PR operations
    âœ… Code review automation
    âœ… Commit & branch operations
    âœ… Webhook handling
    âœ… GitHub Actions triggering
    âœ… Security scanning integration
    """
    
    def __init__(self):
        self.http_client = httpx.AsyncClient(timeout=30.0)
    
    async def validate_credentials(self, credentials: Dict[str, Any]) -> bool:
        """
        Validate GitHub credentials
        
        Required credentials:
        - access_token: GitHub personal access token or OAuth token
        OR
        - app_id: GitHub App ID
        - private_key: GitHub App private key
        """
        
        try:
            access_token = credentials.get("access_token")
            
            if not access_token:
                return False
            
            # Test connection
            auth = Auth.Token(access_token)
            g = Github(auth=auth)
            
            # Verify by getting authenticated user
            user = g.get_user()
            user.login  # This will raise exception if auth fails
            
            return True
        
        except GithubException as e:
            logger.error(f"GitHub authentication failed: {e}")
            return False
        except Exception as e:
            logger.error(f"GitHub credential validation failed: {e}")
            return False
    
    async def execute(
        self,
        event_type: str,
        data: Dict[str, Any],
        credentials: Dict[str, Any],
        configuration: Dict[str, Any]
    ) -> Dict[str, Any]:
        """
        Execute GitHub action
        
        Event types:
        - create_issue: Create new issue
        - create_pr: Create pull request
        - add_comment: Add comment to issue/PR
        - create_review: Create code review
        - trigger_workflow: Trigger GitHub Actions workflow
        - security_scan_completed: Post security scan results
        """
        
        try:
            access_token = credentials["access_token"]
            auth = Auth.Token(access_token)
            g = Github(auth=auth)
            
            # Execute based on event type
            if event_type == "create_issue":
                result = await self._create_issue(g, data, configuration)
            elif event_type == "create_pr":
                result = await self._create_pull_request(g, data, configuration)
            elif event_type == "add_comment":
                result = await self._add_comment(g, data, configuration)
            elif event_type == "create_review":
                result = await self._create_review(g, data, configuration)
            elif event_type == "trigger_workflow":
                result = await self._trigger_workflow(g, data, configuration)
            elif event_type == "security_scan_completed":
                result = await self._post_security_results(g, data, configuration)
            else:
                raise ValueError(f"Unknown event type: {event_type}")
            
            logger.info(f"GitHub {event_type} executed successfully")
            
            return {
                "success": True,
                "result": result
            }
        
        except GithubException as e:
            logger.error(f"GitHub API error: {e}", exc_info=True)
            raise
        except Exception as e:
            logger.error(f"GitHub execution failed: {e}", exc_info=True)
            raise
    
    async def _create_issue(
        self,
        g: Github,
        data: Dict[str, Any],
        configuration: Dict[str, Any]
    ) -> Dict[str, Any]:
        """
        Create GitHub issue
        
        Required data:
        - title: Issue title
        - body: Issue description
        Optional:
        - labels: List of label names
        - assignees: List of usernames
        - milestone: Milestone number
        """
        
        repo_name = configuration.get("repository")
        if not repo_name:
            raise ValueError("GitHub repository not configured")
        
        repo = g.get_repo(repo_name)
        
        # Prepare issue data
        title = data.get("title", "AMAS Task Result")
        body = data.get("body", "")
        labels = data.get("labels", [])
        assignees = data.get("assignees", [])
        milestone = data.get("milestone")
        
        # Create issue
        issue = repo.create_issue(
            title=title,
            body=body,
            labels=labels,
            assignees=assignees,
            milestone=repo.get_milestone(milestone) if milestone else None
        )
        
        logger.info(f"Created GitHub issue #{issue.number}: {title}")
        
        return {
            "issue_number": issue.number,
            "issue_url": issue.html_url,
            "issue_id": issue.id
        }
    
    async def _create_pull_request(
        self,
        g: Github,
        data: Dict[str, Any],
        configuration: Dict[str, Any]
    ) -> Dict[str, Any]:
        """
        Create GitHub pull request
        
        Required data:
        - title: PR title
        - body: PR description
        - head: Head branch name
        - base: Base branch name (default: main)
        """
        
        repo_name = configuration.get("repository")
        if not repo_name:
            raise ValueError("GitHub repository not configured")
        
        repo = g.get_repo(repo_name)
        
        title = data.get("title", "AMAS Generated PR")
        body = data.get("body", "")
        head = data.get("head")
        base = data.get("base", "main")
        
        if not head:
            raise ValueError("Head branch required for PR creation")
        
        # Create pull request
        pr = repo.create_pull(
            title=title,
            body=body,
            head=head,
            base=base
        )
        
        # Add labels if specified
        if data.get("labels"):
            pr.add_to_labels(*data["labels"])
        
        # Add reviewers if specified
        if data.get("reviewers"):
            pr.create_review_request(reviewers=data["reviewers"])
        
        logger.info(f"Created GitHub PR #{pr.number}: {title}")
        
        return {
            "pr_number": pr.number,
            "pr_url": pr.html_url,
            "pr_id": pr.id
        }
    
    async def _add_comment(
        self,
        g: Github,
        data: Dict[str, Any],
        configuration: Dict[str, Any]
    ) -> Dict[str, Any]:
        """
        Add comment to issue or PR
        
        Required data:
        - issue_number: Issue/PR number
        - comment: Comment text
        """
        
        repo_name = configuration.get("repository")
        if not repo_name:
            raise ValueError("GitHub repository not configured")
        
        repo = g.get_repo(repo_name)
        
        issue_number = data.get("issue_number")
        comment_text = data.get("comment")
        
        if not issue_number or not comment_text:
            raise ValueError("issue_number and comment required")
        
        # Get issue (works for both issues and PRs)
        issue = repo.get_issue(number=issue_number)
        
        # Add comment
        comment = issue.create_comment(comment_text)
        
        logger.info(f"Added comment to GitHub issue/PR #{issue_number}")
        
        return {
            "comment_id": comment.id,
            "comment_url": comment.html_url
        }
    
    async def _create_review(
        self,
        g: Github,
        data: Dict[str, Any],
        configuration: Dict[str, Any]
    ) -> Dict[str, Any]:
        """
        Create code review on pull request
        
        Required data:
        - pr_number: PR number
        - body: Review comment
        - event: Review event (APPROVE, REQUEST_CHANGES, COMMENT)
        Optional:
        - comments: List of line comments
        """
        
        repo_name = configuration.get("repository")
        if not repo_name:
            raise ValueError("GitHub repository not configured")
        
        repo = g.get_repo(repo_name)
        
        pr_number = data.get("pr_number")
        body = data.get("body", "")
        event = data.get("event", "COMMENT")
        comments = data.get("comments", [])
        
        if not pr_number:
            raise ValueError("pr_number required")
        
        # Get pull request
        pr = repo.get_pull(number=pr_number)
        
        # Create review
        if comments:
            # Review with inline comments
            review = pr.create_review(
                body=body,
                event=event,
                comments=comments
            )
        else:
            # Simple review
            review = pr.create_review(
                body=body,
                event=event
            )
        
        logger.info(f"Created review on GitHub PR #{pr_number}")
        
        return {
            "review_id": review.id,
            "review_url": review.html_url
        }
    
    async def _trigger_workflow(
        self,
        g: Github,
        data: Dict[str, Any],
        configuration: Dict[str, Any]
    ) -> Dict[str, Any]:
        """
        Trigger GitHub Actions workflow
        
        Required data:
        - workflow_id: Workflow ID or filename
        - ref: Git ref (branch/tag)
        Optional:
        - inputs: Workflow inputs
        """
        
        repo_name = configuration.get("repository")
        if not repo_name:
            raise ValueError("GitHub repository not configured")
        
        repo = g.get_repo(repo_name)
        
        workflow_id = data.get("workflow_id")
        ref = data.get("ref", "main")
        inputs = data.get("inputs", {})
        
        if not workflow_id:
            raise ValueError("workflow_id required")
        
        # Get workflow
        workflow = repo.get_workflow(workflow_id)
        
        # Trigger workflow
        result = workflow.create_dispatch(ref=ref, inputs=inputs)
        
        logger.info(f"Triggered GitHub Actions workflow: {workflow_id}")
        
        return {
            "workflow_id": workflow.id,
            "workflow_name": workflow.name,
            "triggered": result
        }
    
    async def _post_security_results(
        self,
        g: Github,
        data: Dict[str, Any],
        configuration: Dict[str, Any]
    ) -> Dict[str, Any]:
        """
        Post security scan results as GitHub issue
        
        Required data:
        - scan_results: Security scan results
        - target: Scan target
        - vulnerabilities: List of vulnerabilities
        """
        
        repo_name = configuration.get("repository")
        if not repo_name:
            raise ValueError("GitHub repository not configured")
        
        repo = g.get_repo(repo_name)
        
        target = data.get("target", "Unknown")
        vulnerabilities = data.get("vulnerabilities", [])
        scan_summary = data.get("scan_summary", {})
        
        # Build issue body
        body = f"""# ðŸ”’ Security Scan Results

**Target:** `{target}`
**Scan Date:** {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}
**Total Vulnerabilities:** {len(vulnerabilities)}

## Summary

"""
        
        # Count by severity
        severity_counts = {}
        for vuln in vulnerabilities:
            severity = vuln.get("severity", "Unknown")
            severity_counts[severity] = severity_counts.get(severity, 0) + 1
        
        for severity, count in sorted(severity_counts.items()):
            emoji = {
                "Critical": "ðŸ”´",
                "High": "ðŸŸ ",
                "Medium": "ðŸŸ¡",
                "Low": "ðŸŸ¢"
            }.get(severity, "âšª")
            body += f"- {emoji} **{severity}:** {count}\n"
        
        body += "\n## Vulnerabilities\n\n"
        
        # List vulnerabilities
        for i, vuln in enumerate(vulnerabilities, 1):
            severity = vuln.get("severity", "Unknown")
            title = vuln.get("title", "Unknown Vulnerability")
            description = vuln.get("description", "")
            cwe = vuln.get("cwe", "")
            cvss = vuln.get("cvss_score", "")
            
            body += f"### {i}. {title}\n\n"
            body += f"**Severity:** {severity}\n"
            if cwe:
                body += f"**CWE:** {cwe}\n"
            if cvss:
                body += f"**CVSS Score:** {cvss}\n"
            body += f"\n{description}\n\n"
            
            # Add remediation if available
            if vuln.get("remediation"):
                body += f"**Remediation:**\n{vuln['remediation']}\n\n"
            
            body += "---\n\n"
        
        # Create issue
        issue = repo.create_issue(
            title=f"ðŸ”’ Security Scan: {target}",
            body=body,
            labels=["security", "vulnerability-scan"]
        )
        
        logger.info(f"Posted security scan results to GitHub issue #{issue.number}")
        
        return {
            "issue_number": issue.number,
            "issue_url": issue.html_url,
            "vulnerability_count": len(vulnerabilities)
        }
    
    async def validate_webhook_signature(
        self,
        payload: Dict[str, Any],
        headers: Dict[str, str]
    ) -> bool:
        """
        Validate webhook signature from GitHub
        
        GitHub sends signature in X-Hub-Signature-256 header
        """
        
        try:
            signature = headers.get("X-Hub-Signature-256")
            webhook_secret = headers.get("webhook_secret", "")
            
            if not signature or not webhook_secret:
                logger.warning("Missing signature or secret in GitHub webhook")
                return True  # Skip validation if no secret configured
            
            # Compute expected signature
            payload_str = json.dumps(payload, separators=(',', ':'))
            expected_signature = "sha256=" + hmac.new(
                webhook_secret.encode(),
                payload_str.encode(),
                hashlib.sha256
            ).hexdigest()
            
            return hmac.compare_digest(signature, expected_signature)
        
        except Exception as e:
            logger.error(f"GitHub signature validation error: {e}")
            return False
    
    async def parse_webhook(self, payload: Dict[str, Any]) -> Dict[str, Any]:
        """
        Parse incoming GitHub webhook
        
        Returns:
            Parsed event data
        """
        
        event_type = payload.get("action", "unknown")
        
        # GitHub webhook structure varies by event
        if "issue" in payload:
            return {
                "type": f"issue_{event_type}",
                "data": {
                    "issue_number": payload["issue"]["number"],
                    "issue_title": payload["issue"]["title"],
                    "repository": payload["repository"]["full_name"],
                    "sender": payload["sender"]["login"]
                }
            }
        
        elif "pull_request" in payload:
            return {
                "type": f"pull_request_{event_type}",
                "data": {
                    "pr_number": payload["pull_request"]["number"],
                    "pr_title": payload["pull_request"]["title"],
                    "repository": payload["repository"]["full_name"],
                    "sender": payload["sender"]["login"]
                }
            }
        
        elif "push" in payload:
            return {
                "type": "push",
                "data": {
                    "ref": payload.get("ref"),
                    "repository": payload["repository"]["full_name"],
                    "commits": payload.get("commits", [])
                }
            }
        
        else:
            return {
                "type": event_type,
                "data": payload
            }
```

***

### **Step 5B.2: Notion Integration**

**File**: `src/amas/integration/notion_connector.py` (CREATE NEW)

```python
# src/amas/integration/notion_connector.py (COMPLETE NOTION INTEGRATION)
import asyncio
import httpx
from typing import Any, Dict, List, Optional
import logging
from notion_client import AsyncClient
from notion_client.errors import APIResponseError

logger = logging.getLogger(__name__)

class NotionConnector:
    """
    Notion Workspace Connector
    
    âœ… Page creation & updates
    âœ… Database operations
    âœ… Block manipulation
    âœ… Property management
    âœ… Search functionality
    âœ… File attachments
    """
    
    def __init__(self):
        self.http_client = httpx.AsyncClient(timeout=30.0)
    
    async def validate_credentials(self, credentials: Dict[str, Any]) -> bool:
        """
        Validate Notion credentials
        
        Required credentials:
        - api_key: Notion integration token
        """
        
        try:
            api_key = credentials.get("api_key")
            
            if not api_key:
                return False
            
            # Test connection
            notion = AsyncClient(auth=api_key)
            
            # Try to list users (basic API test)
            await notion.users.list()
            
            return True
        
        except APIResponseError as e:
            logger.error(f"Notion authentication failed: {e}")
            return False
        except Exception as e:
            logger.error(f"Notion credential validation failed: {e}")
            return False
    
    async def execute(
        self,
        event_type: str,
        data: Dict[str, Any],
        credentials: Dict[str, Any],
        configuration: Dict[str, Any]
    ) -> Dict[str, Any]:
        """
        Execute Notion action
        
        Event types:
        - create_page: Create new page
        - update_page: Update existing page
        - create_database_entry: Add entry to database
        - update_database_entry: Update database entry
        - append_blocks: Add content blocks to page
        """
        
        try:
            api_key = credentials["api_key"]
            notion = AsyncClient(auth=api_key)
            
            # Execute based on event type
            if event_type == "create_page":
                result = await self._create_page(notion, data, configuration)
            elif event_type == "update_page":
                result = await self._update_page(notion, data, configuration)
            elif event_type == "create_database_entry":
                result = await self._create_database_entry(notion, data, configuration)
            elif event_type == "update_database_entry":
                result = await self._update_database_entry(notion, data, configuration)
            elif event_type == "append_blocks":
                result = await self._append_blocks(notion, data, configuration)
            else:
                raise ValueError(f"Unknown event type: {event_type}")
            
            logger.info(f"Notion {event_type} executed successfully")
            
            return {
                "success": True,
                "result": result
            }
        
        except APIResponseError as e:
            logger.error(f"Notion API error: {e}", exc_info=True)
            raise
        except Exception as e:
            logger.error(f"Notion execution failed: {e}", exc_info=True)
            raise
    
    async def _create_page(
        self,
        notion: AsyncClient,
        data: Dict[str, Any],
        configuration: Dict[str, Any]
    ) -> Dict[str, Any]:
        """
        Create new Notion page
        
        Required data:
        - title: Page title
        - content: Page content (blocks)
        Required configuration:
        - parent_page_id: Parent page ID
        """
        
        parent_page_id = configuration.get("parent_page_id")
        if not parent_page_id:
            raise ValueError("Notion parent_page_id not configured")
        
        title = data.get("title", "AMAS Task Result")
        content = data.get("content", [])
        
        # Prepare page properties
        properties = {
            "title": {
                "title": [
                    {
                        "text": {
                            "content": title
                        }
                    }
                ]
            }
        }
        
        # Create page
        page = await notion.pages.create(
            parent={"page_id": parent_page_id},
            properties=properties,
            children=content if content else []
        )
        
        logger.info(f"Created Notion page: {title}")
        
        return {
            "page_id": page["id"],
            "page_url": page["url"],
            "title": title
        }
    
    async def _update_page(
        self,
        notion: AsyncClient,
        data: Dict[str, Any],
        configuration: Dict[str, Any]
    ) -> Dict[str, Any]:
        """
        Update existing Notion page
        
        Required data:
        - page_id: Page ID to update
        - properties: Properties to update
        """
        
        page_id = data.get("page_id")
        properties = data.get("properties", {})
        
        if not page_id:
            raise ValueError("page_id required for update")
        
        # Update page
        page = await notion.pages.update(
            page_id=page_id,
            properties=properties
        )
        
        logger.info(f"Updated Notion page: {page_id}")
        
        return {
            "page_id": page["id"],
            "page_url": page["url"]
        }
    
    async def _create_database_entry(
        self,
        notion: AsyncClient,
        data: Dict[str, Any],
        configuration: Dict[str, Any]
    ) -> Dict[str, Any]:
        """
        Create entry in Notion database
        
        Required data:
        - properties: Database entry properties
        Required configuration:
        - database_id: Database ID
        """
        
        database_id = configuration.get("database_id")
        if not database_id:
            raise ValueError("Notion database_id not configured")
        
        properties = data.get("properties", {})
        
        # Create database entry
        page = await notion.pages.create(
            parent={"database_id": database_id},
            properties=properties
        )
        
        logger.info(f"Created Notion database entry: {page['id']}")
        
        return {
            "page_id": page["id"],
            "page_url": page["url"]
        }
    
    async def _update_database_entry(
        self,
        notion: AsyncClient,
        data: Dict[str, Any],
        configuration: Dict[str, Any]
    ) -> Dict[str, Any]:
        """Update database entry"""
        
        page_id = data.get("page_id")
        properties = data.get("properties", {})
        
        if not page_id:
            raise ValueError("page_id required for update")
        
        # Update database entry
        page = await notion.pages.update(
            page_id=page_id,
            properties=properties
        )
        
        logger.info(f"Updated Notion database entry: {page_id}")
        
        return {
            "page_id": page["id"],
            "page_url": page["url"]
        }
    
    async def _append_blocks(
        self,
        notion: AsyncClient,
        data: Dict[str, Any],
        configuration: Dict[str, Any]
    ) -> Dict[str, Any]:
        """
        Append content blocks to page
        
        Required data:
        - page_id: Page ID
        - blocks: List of blocks to append
        """
        
        page_id = data.get("page_id")
        blocks = data.get("blocks", [])
        
        if not page_id:
            raise ValueError("page_id required")
        
        # Append blocks
        result = await notion.blocks.children.append(
            block_id=page_id,
            children=blocks
        )
        
        logger.info(f"Appended {len(blocks)} blocks to Notion page {page_id}")
        
        return {
            "page_id": page_id,
            "blocks_added": len(blocks)
        }
    
    async def create_task_report(
        self,
        task_data: Dict[str, Any],
        credentials: Dict[str, Any],
        configuration: Dict[str, Any]
    ) -> Dict[str, Any]:
        """
        Create formatted task report in Notion
        
        Builds a nicely formatted page with task results
        """
        
        api_key = credentials["api_key"]
        notion = AsyncClient(auth=api_key)
        
        parent_page_id = configuration.get("parent_page_id")
        if not parent_page_id:
            raise ValueError("Notion parent_page_id not configured")
        
        task_id = task_data.get("task_id", "Unknown")
        task_title = task_data.get("title", "Task Result")
        task_type = task_data.get("task_type", "unknown")
        status = task_data.get("status", "completed")
        duration = task_data.get("duration", 0)
        result = task_data.get("result", {})
        
        # Build page content with blocks
        blocks = [
            # Header
            {
                "object": "block",
                "type": "heading_1",
                "heading_1": {
                    "rich_text": [
                        {
                            "type": "text",
                            "text": {
                                "content": f"Task Report: {task_title}"
                            }
                        }
                    ]
                }
            },
            # Task metadata
            {
                "object": "block",
                "type": "callout",
                "callout": {
                    "rich_text": [
                        {
                            "type": "text",
                            "text": {
                                "content": f"Task ID: {task_id}\nType: {task_type}\nStatus: {status}\nDuration: {duration:.1f}s"
                            }
                        }
                    ],
                    "icon": {
                        "emoji": "âœ…" if status == "completed" else "âŒ"
                    }
                }
            },
            # Results section
            {
                "object": "block",
                "type": "heading_2",
                "heading_2": {
                    "rich_text": [
                        {
                            "type": "text",
                            "text": {
                                "content": "Results"
                            }
                        }
                    ]
                }
            },
            {
                "object": "block",
                "type": "code",
                "code": {
                    "rich_text": [
                        {
                            "type": "text",
                            "text": {
                                "content": json.dumps(result, indent=2)
                            }
                        }
                    ],
                    "language": "json"
                }
            }
        ]
        
        # Create page
        page = await notion.pages.create(
            parent={"page_id": parent_page_id},
            properties={
                "title": {
                    "title": [
                        {
                            "text": {
                                "content": task_title
                            }
                        }
                    ]
                }
            },
            children=blocks
        )
        
        logger.info(f"Created Notion task report: {task_title}")
        
        return {
            "page_id": page["id"],
            "page_url": page["url"]
        }
    
    async def validate_webhook_signature(
        self,
        payload: Dict[str, Any],
        headers: Dict[str, str]
    ) -> bool:
        """
        Validate webhook signature from Notion
        
        Note: Notion doesn't currently support webhook signatures
        """
        # Notion webhooks don't have signature validation yet
        return True
    
    async def parse_webhook(self, payload: Dict[str, Any]) -> Dict[str, Any]:
        """
        Parse incoming Notion webhook
        
        Returns:
            Parsed event data
        """
        
        # Notion webhook structure (when available)
        return {
            "type": payload.get("event", "notion_webhook"),
            "data": payload
        }
```

***

### **Step 5B.3: Jira Integration**

**File**: `src/amas/integration/jira_connector.py` (CREATE NEW)

```python
# src/amas/integration/jira_connector.py (COMPLETE JIRA INTEGRATION)
import asyncio
import httpx
from typing import Any, Dict, List, Optional
import logging
from jira import JIRA
from jira.exceptions import JIRAError

logger = logging.getLogger(__name__)

class JiraConnector:
    """
    Jira Project Management Connector
    
    âœ… Issue creation & updates
    âœ… Status transitions
    âœ… Comment posting
    âœ… Sprint management
    âœ… Custom field handling
    âœ… Attachment uploads
    âœ… JQL queries
    """
    
    def __init__(self):
        self.http_client = httpx.AsyncClient(timeout=30.0)
    
    async def validate_credentials(self, credentials: Dict[str, Any]) -> bool:
        """
        Validate Jira credentials
        
        Required credentials:
        - server: Jira server URL
        - email: Jira user email
        - api_token: Jira API token
        """
        
        try:
            server = credentials.get("server")
            email = credentials.get("email")
            api_token = credentials.get("api_token")
            
            if not all([server, email, api_token]):
                return False
            
            # Test connection
            jira = JIRA(
                server=server,
                basic_auth=(email, api_token)
            )
            
            # Try to get current user
            jira.myself()
            
            return True
        
        except JIRAError as e:
            logger.error(f"Jira authentication failed: {e}")
            return False
        except Exception as e:
            logger.error(f"Jira credential validation failed: {e}")
            return False
    
    async def execute(
        self,
        event_type: str,
        data: Dict[str, Any],
        credentials: Dict[str, Any],
        configuration: Dict[str, Any]
    ) -> Dict[str, Any]:
        """
        Execute Jira action
        
        Event types:
        - create_issue: Create new issue (bug, task, story)
        - update_issue: Update existing issue
        - add_comment: Add comment to issue
        - transition_issue: Change issue status
        - create_bug_from_scan: Create bug from security scan
        """
        
        try:
            server = credentials["server"]
            email = credentials["email"]
            api_token = credentials["api_token"]
            
            jira = JIRA(
                server=server,
                basic_auth=(email, api_token)
            )
            
            # Execute based on event type
            if event_type == "create_issue":
                result = await self._create_issue(jira, data, configuration)
            elif event_type == "update_issue":
                result = await self._update_issue(jira, data, configuration)
            elif event_type == "add_comment":
                result = await self._add_comment(jira, data, configuration)
            elif event_type == "transition_issue":
                result = await self._transition_issue(jira, data, configuration)
            elif event_type == "create_bug_from_scan":
                result = await self._create_bug_from_scan(jira, data, configuration)
            else:
                raise ValueError(f"Unknown event type: {event_type}")
            
            logger.info(f"Jira {event_type} executed successfully")
            
            return {
                "success": True,
                "result": result
            }
        
        except JIRAError as e:
            logger.error(f"Jira API error: {e}", exc_info=True)
            raise
        except Exception as e:
            logger.error(f"Jira execution failed: {e}", exc_info=True)
            raise
    
    async def _create_issue(
        self,
        jira: JIRA,
        data: Dict[str, Any],
        configuration: Dict[str, Any]
    ) -> Dict[str, Any]:
        """
        Create Jira issue
        
        Required data:
        - summary: Issue title
        - description: Issue description
        - issue_type: Issue type (Bug, Task, Story, etc.)
        Required configuration:
        - project_key: Jira project key
        """
        
        project_key = configuration.get("project_key")
        if not project_key:
            raise ValueError("Jira project_key not configured")
        
        summary = data.get("summary", "AMAS Task Result")
        description = data.get("description", "")
        issue_type = data.get("issue_type", "Task")
        priority = data.get("priority", "Medium")
        labels = data.get("labels", [])
        assignee = data.get("assignee")
        
        # Prepare issue fields
        issue_fields = {
            "project": {"key": project_key},
            "summary": summary,
            "description": description,
            "issuetype": {"name": issue_type},
            "priority": {"name": priority}
        }
        
        # Add optional fields
        if labels:
            issue_fields["labels"] = labels
        
        if assignee:
            issue_fields["assignee"] = {"name": assignee}
        
        # Add custom fields if provided
        custom_fields = data.get("custom_fields", {})
        issue_fields.update(custom_fields)
        
        # Create issue
        issue = jira.create_issue(fields=issue_fields)
        
        logger.info(f"Created Jira issue {issue.key}: {summary}")
        
        return {
            "issue_key": issue.key,
            "issue_id": issue.id,
            "issue_url": f"{jira.server_url}/browse/{issue.key}"
        }
    
    async def _update_issue(
        self,
        jira: JIRA,
        data: Dict[str, Any],
        configuration: Dict[str, Any]
    ) -> Dict[str, Any]:
        """Update existing Jira issue"""
        
        issue_key = data.get("issue_key")
        fields = data.get("fields", {})
        
        if not issue_key:
            raise ValueError("issue_key required for update")
        
        # Get issue
        issue = jira.issue(issue_key)
        
        # Update fields
        issue.update(fields=fields)
        
        logger.info(f"Updated Jira issue {issue_key}")
        
        return {
            "issue_key": issue_key,
            "updated_fields": list(fields.keys())
        }
    
    async def _add_comment(
        self,
        jira: JIRA,
        data: Dict[str, Any],
        configuration: Dict[str, Any]
    ) -> Dict[str, Any]:
        """Add comment to Jira issue"""
        
        issue_key = data.get("issue_key")
        comment_text = data.get("comment")
        
        if not issue_key or not comment_text:
            raise ValueError("issue_key and comment required")
        
        # Add comment
        comment = jira.add_comment(issue_key, comment_text)
        
        logger.info(f"Added comment to Jira issue {issue_key}")
        
        return {
            "issue_key": issue_key,
            "comment_id": comment.id
        }
    
    async def _transition_issue(
        self,
        jira: JIRA,
        data: Dict[str, Any],
        configuration: Dict[str, Any]
    ) -> Dict[str, Any]:
        """
        Transition issue to new status
        
        Required data:
        - issue_key: Issue key
        - transition: Transition name or ID
        """
        
        issue_key = data.get("issue_key")
        transition = data.get("transition")
        
        if not issue_key or not transition:
            raise ValueError("issue_key and transition required")
        
        # Get issue
        issue = jira.issue(issue_key)
        
        # Transition issue
        jira.transition_issue(issue, transition)
        
        logger.info(f"Transitioned Jira issue {issue_key} to {transition}")
        
        return {
            "issue_key": issue_key,
            "new_status": transition
        }
    
    async def _create_bug_from_scan(
        self,
        jira: JIRA,
        data: Dict[str, Any],
        configuration: Dict[str, Any]
    ) -> Dict[str, Any]:
        """
        Create bug from security scan results
        
        Required data:
        - vulnerability: Vulnerability details
        - target: Scan target
        """
        
        project_key = configuration.get("project_key")
        if not project_key:
            raise ValueError("Jira project_key not configured")
        
        vulnerability = data.get("vulnerability", {})
        target = data.get("target", "Unknown")
        
        # Extract vulnerability details
        vuln_title = vulnerability.get("title", "Security Vulnerability")
        vuln_description = vulnerability.get("description", "")
        vuln_severity = vulnerability.get("severity", "Medium")
        vuln_cwe = vulnerability.get("cwe", "")
        vuln_cvss = vulnerability.get("cvss_score", "")
        remediation = vulnerability.get("remediation", "")
        
        # Map severity to Jira priority
        priority_map = {
            "Critical": "Highest",
            "High": "High",
            "Medium": "Medium",
            "Low": "Low"
        }
        priority = priority_map.get(vuln_severity, "Medium")
        
        # Build description
        description = f"""Security vulnerability found in: {target}

*Vulnerability Details:*
{vuln_description}

*Severity:* {vuln_severity}
"""
        
        if vuln_cwe:
            description += f"*CWE:* {vuln_cwe}\n"
        
        if vuln_cvss:
            description += f"*CVSS Score:* {vuln_cvss}\n"
        
        if remediation:
            description += f"""
*Remediation:*
{remediation}
"""
        
        # Create bug issue
        issue_fields = {
            "project": {"key": project_key},
            "summary": f"{vuln_title} - {target}",
            "description": description,
            "issuetype": {"name": "Bug"},
            "priority": {"name": priority},
            "labels": ["security", "vulnerability", "amas-scan"]
        }
        
        issue = jira.create_issue(fields=issue_fields)
        
        logger.info(f"Created Jira bug {issue.key} from security scan")
        
        return {
            "issue_key": issue.key,
            "issue_id": issue.id,
            "issue_url": f"{jira.server_url}/browse/{issue.key}",
            "vulnerability_title": vuln_title
        }
    
    async def query_issues(
        self,
        jql_query: str,
        credentials: Dict[str, Any],
        max_results: int = 50
    ) -> List[Dict[str, Any]]:
        """
        Execute JQL query
        
        Args:
            jql_query: Jira Query Language query
            credentials: Jira credentials
            max_results: Maximum results to return
        
        Returns:
            List of issues
        """
        
        try:
            server = credentials["server"]
            email = credentials["email"]
            api_token = credentials["api_token"]
            
            jira = JIRA(
                server=server,
                basic_auth=(email, api_token)
            )
            
            # Execute query
            issues = jira.search_issues(jql_query, maxResults=max_results)
            
            # Convert to dict
            result = []
            for issue in issues:
                result.append({
                    "key": issue.key,
                    "id": issue.id,
                    "summary": issue.fields.summary,
                    "status": issue.fields.status.name,
                    "priority": issue.fields.priority.name if issue.fields.priority else None,
                    "assignee": issue.fields.assignee.displayName if issue.fields.assignee else None,
                    "created": issue.fields.created,
                    "updated": issue.fields.updated
                })
            
            return result
        
        except JIRAError as e:
            logger.error(f"JQL query failed: {e}")
            raise
    
    async def validate_webhook_signature(
        self,
        payload: Dict[str, Any],
        headers: Dict[str, str]
    ) -> bool:
        """
        Validate webhook signature from Jira
        
        Jira doesn't provide signature validation by default
        """
        # Jira webhooks don't have built-in signature validation
        # Can be implemented with custom authentication
        return True
    
    async def parse_webhook(self, payload: Dict[str, Any]) -> Dict[str, Any]:
        """
        Parse incoming Jira webhook
        
        Returns:
            Parsed event data
        """
        
        webhook_event = payload.get("webhookEvent", "unknown")
        issue_event_type = payload.get("issue_event_type_name", "")
        
        event_type = f"{webhook_event}_{issue_event_type}" if issue_event_type else webhook_event
        
        issue_data = {}
        if "issue" in payload:
            issue = payload["issue"]
            issue_data = {
                "key": issue.get("key"),
                "id": issue.get("id"),
                "summary": issue.get("fields", {}).get("summary"),
                "status": issue.get("fields", {}).get("status", {}).get("name")
            }
        
        return {
            "type": event_type,
            "data": {
                "issue": issue_data,
                "user": payload.get("user", {}).get("displayName"),
                "changelog": payload.get("changelog")
            }
        }
```

***

## **PART 5C: INTEGRATION API ENDPOINTS**

### **Step 5C.1: Integration Management API**

**File**: `src/api/routes/integrations.py` (CREATE NEW)

```python
# src/api/routes/integrations.py (COMPLETE INTEGRATION API)
from fastapi import APIRouter, Depends, HTTPException, Query, Body, Header
from typing import List, Optional, Dict, Any
import logging
from datetime import datetime

from src.amas.integration.integration_manager import (
    get_integration_manager,
    IntegrationManager,
    IntegrationPlatform,
    IntegrationStatus
)
from src.api.auth import get_current_user, require_permission
from src.api.models import (
    IntegrationCreateRequest,
    IntegrationResponse,
    IntegrationTriggerRequest,
    IntegrationListResponse,
    WebhookEventResponse
)
from src.database.connection import get_db

router = APIRouter()
logger = logging.getLogger(__name__)

@router.post("/", response_model=IntegrationResponse)
async def create_integration(
    integration_request: IntegrationCreateRequest,
    current_user = Depends(get_current_user),
    integration_manager: IntegrationManager = Depends(get_integration_manager),
    db = Depends(get_db)
):
    """
    Register new integration
    
    âœ… Platform credential validation
    âœ… Configuration setup
    âœ… Webhook URL generation
    âœ… Database persistence
    """
    
    require_permission(current_user, "INTEGRATION_CREATE")
    
    try:
        # Validate platform
        try:
            platform = IntegrationPlatform(integration_request.platform)
        except ValueError:
            raise HTTPException(
                status_code=400,
                detail=f"Invalid platform: {integration_request.platform}"
            )
        
        # Register integration
        integration_id = await integration_manager.register_integration(
            user_id=current_user.id,
            platform=platform,
            credentials=integration_request.credentials,
            configuration=integration_request.configuration or {}
        )
        
        # Persist to database
        await db.execute(
            """
            INSERT INTO integrations (
                integration_id, user_id, platform, status,
                credentials, configuration, created_at
            ) VALUES ($1, $2, $3, $4, $5, $6, $7)
            """,
            integration_id,
            current_user.id,
            platform.value,
            IntegrationStatus.ACTIVE.value,
            json.dumps(integration_request.credentials),  # Encrypt in production
            json.dumps(integration_request.configuration or {}),
            datetime.now()
        )
        
        logger.info(f"Integration created: {integration_id} ({platform.value}) for user {current_user.id}")
        
        # Generate webhook URL
        webhook_url = f"https://your-amas.com/api/v1/integrations/webhooks/{platform.value}"
        
        return IntegrationResponse(
            integration_id=integration_id,
            user_id=current_user.id,
            platform=platform.value,
            status=IntegrationStatus.ACTIVE.value,
            webhook_url=webhook_url,
            created_at=datetime.now().isoformat(),
            message="Integration created successfully"
        )
    
    except Exception as e:
        logger.error(f"Integration creation failed: {e}", exc_info=True)
        raise HTTPException(
            status_code=500,
            detail=f"Failed to create integration: {str(e)}"
        )

@router.get("/", response_model=IntegrationListResponse)
async def list_integrations(
    platform: Optional[str] = Query(None, description="Filter by platform"),
    status: Optional[str] = Query(None, description="Filter by status"),
    current_user = Depends(get_current_user),
    integration_manager: IntegrationManager = Depends(get_integration_manager)
):
    """
    List user's integrations
    
    âœ… Filter by platform
    âœ… Filter by status
    âœ… Pagination support
    """
    
    require_permission(current_user, "INTEGRATION_READ")
    
    try:
        # Convert platform string to enum if provided
        platform_enum = None
        if platform:
            try:
                platform_enum = IntegrationPlatform(platform)
            except ValueError:
                raise HTTPException(
                    status_code=400,
                    detail=f"Invalid platform: {platform}"
                )
        
        # Get integrations
        integrations = await integration_manager.list_integrations(
            user_id=current_user.id,
            platform=platform_enum
        )
        
        # Apply status filter if provided
        if status:
            integrations = [
                i for i in integrations 
                if i["status"] == status
            ]
        
        return IntegrationListResponse(
            integrations=integrations,
            total=len(integrations)
        )
    
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Failed to list integrations: {e}", exc_info=True)
        raise HTTPException(
            status_code=500,
            detail=f"Failed to list integrations: {str(e)}"
        )

@router.get("/{integration_id}", response_model=IntegrationResponse)
async def get_integration(
    integration_id: str,
    current_user = Depends(get_current_user),
    integration_manager: IntegrationManager = Depends(get_integration_manager)
):
    """Get integration details"""
    
    require_permission(current_user, "INTEGRATION_READ")
    
    try:
        integration = await integration_manager.get_integration_status(integration_id)
        
        # Verify ownership
        if integration["user_id"] != current_user.id:
            raise HTTPException(
                status_code=403,
                detail="Not authorized to access this integration"
            )
        
        return IntegrationResponse(**integration)
    
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Failed to get integration: {e}", exc_info=True)
        raise HTTPException(
            status_code=404,
            detail="Integration not found"
        )

@router.post("/{integration_id}/trigger", response_model=Dict[str, Any])
async def trigger_integration(
    integration_id: str,
    trigger_request: IntegrationTriggerRequest,
    current_user = Depends(get_current_user),
    integration_manager: IntegrationManager = Depends(get_integration_manager)
):
    """
    Manually trigger integration
    
    âœ… Event type specification
    âœ… Custom data payload
    âœ… Async execution
    âœ… Result tracking
    """
    
    require_permission(current_user, "INTEGRATION_EXECUTE")
    
    try:
        # Verify ownership
        integration = await integration_manager.get_integration_status(integration_id)
        if integration["user_id"] != current_user.id:
            raise HTTPException(
                status_code=403,
                detail="Not authorized to trigger this integration"
            )
        
        # Trigger integration
        result = await integration_manager.trigger_integration(
            integration_id=integration_id,
            event_type=trigger_request.event_type,
            data=trigger_request.data
        )
        
        logger.info(f"Integration {integration_id} triggered: {trigger_request.event_type}")
        
        return {
            "success": True,
            "integration_id": integration_id,
            "event_type": trigger_request.event_type,
            "result": result
        }
    
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Integration trigger failed: {e}", exc_info=True)
        raise HTTPException(
            status_code=500,
            detail=f"Failed to trigger integration: {str(e)}"
        )

@router.delete("/{integration_id}")
async def delete_integration(
    integration_id: str,
    current_user = Depends(get_current_user),
    integration_manager: IntegrationManager = Depends(get_integration_manager),
    db = Depends(get_db)
):
    """Delete integration"""
    
    require_permission(current_user, "INTEGRATION_DELETE")
    
    try:
        # Verify ownership
        integration = await integration_manager.get_integration_status(integration_id)
        if integration["user_id"] != current_user.id:
            raise HTTPException(
                status_code=403,
                detail="Not authorized to delete this integration"
            )
        
        # Remove from manager
        if integration_id in integration_manager.active_integrations:
            del integration_manager.active_integrations[integration_id]
        
        # Update database
        await db.execute(
            "UPDATE integrations SET status = $1 WHERE integration_id = $2",
            IntegrationStatus.INACTIVE.value,
            integration_id
        )
        
        logger.info(f"Integration deleted: {integration_id}")
        
        return {
            "success": True,
            "message": "Integration deleted successfully"
        }
    
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Integration deletion failed: {e}", exc_info=True)
        raise HTTPException(
            status_code=500,
            detail=f"Failed to delete integration: {str(e)}"
        )

# ========================================================================
# WEBHOOK ENDPOINTS
# ========================================================================

@router.post("/webhooks/{platform}", response_model=WebhookEventResponse)
async def handle_webhook(
    platform: str,
    payload: Dict[str, Any] = Body(...),
    x_hub_signature: Optional[str] = Header(None),
    x_slack_signature: Optional[str] = Header(None),
    x_n8n_signature: Optional[str] = Header(None),
    integration_manager: IntegrationManager = Depends(get_integration_manager)
):
    """
    Universal webhook endpoint for all platforms
    
    âœ… Signature validation
    âœ… Event parsing
    âœ… Async processing
    âœ… Error handling
    
    Supported platforms:
    - n8n, slack, github, notion, jira, salesforce
    """
    
    try:
        # Validate platform
        try:
            platform_enum = IntegrationPlatform(platform)
        except ValueError:
            raise HTTPException(
                status_code=400,
                detail=f"Invalid platform: {platform}"
            )
        
        # Collect headers
        headers = {}
        if x_hub_signature:
            headers["X-Hub-Signature-256"] = x_hub_signature
        if x_slack_signature:
            headers["X-Slack-Signature"] = x_slack_signature
        if x_n8n_signature:
            headers["X-N8N-Signature"] = x_n8n_signature
        
        # Handle webhook
        result = await integration_manager.handle_webhook(
            platform=platform_enum,
            payload=payload,
            headers=headers
        )
        
        logger.info(f"Webhook processed: {platform} - {result.get('event_type')}")
        
        return WebhookEventResponse(
            status="received",
            platform=platform,
            event_type=result.get("event_type"),
            timestamp=datetime.now().isoformat()
        )
    
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Webhook handling failed: {e}", exc_info=True)
        raise HTTPException(
            status_code=500,
            detail=f"Webhook processing failed: {str(e)}"
        )

@router.get("/webhooks/test/{platform}")
async def test_webhook(
    platform: str,
    current_user = Depends(get_current_user)
):
    """
    Test webhook endpoint
    
    Returns example payload for platform
    """
    
    require_permission(current_user, "INTEGRATION_READ")
    
    # Example payloads for each platform
    examples = {
        "n8n": {
            "event": "workflow_completed",
            "workflowId": "123",
            "executionId": "456",
            "data": {"result": "success"}
        },
        "slack": {
            "type": "event_callback",
            "event": {
                "type": "message",
                "text": "Hello AMAS"
            }
        },
        "github": {
            "action": "opened",
            "issue": {
                "number": 123,
                "title": "Test Issue"
            }
        }
    }
    
    return {
        "platform": platform,
        "example_payload": examples.get(platform, {}),
        "webhook_url": f"https://your-amas.com/api/v1/integrations/webhooks/{platform}"
    }
```

***

### **Step 5C.2: Register Integration Routes in Main App**

**File**: `src/api/main.py` (ADD INTEGRATION ROUTES)

```python
# src/api/main.py (ADD THIS)
from src.api.routes import integrations

app.include_router(
    integrations.router,
    prefix="/api/v1/integrations",
    tags=["Integrations"]
)

# Start integration event queue processor on startup
@app.on_event("startup")
async def start_integration_processor():
    from src.amas.integration.integration_manager import get_integration_manager
    
    integration_manager = get_integration_manager()
    
    # Start background event processor
    asyncio.create_task(integration_manager.process_event_queue())
    
    logger.info("Integration event processor started")
```

***

### **Step 5C.3: Pydantic Models for Integration API**

**File**: `src/api/models.py` (ADD INTEGRATION MODELS)

```python
# src/api/models.py (ADD THESE MODELS)
from pydantic import BaseModel, Field
from typing import Dict, Any, Optional, List
from datetime import datetime

class IntegrationCreateRequest(BaseModel):
    """Request model for creating integration"""
    platform: str = Field(..., description="Integration platform (n8n, slack, github, etc.)")
    credentials: Dict[str, Any] = Field(..., description="Platform credentials")
    configuration: Optional[Dict[str, Any]] = Field(None, description="Platform configuration")

class IntegrationResponse(BaseModel):
    """Response model for integration"""
    integration_id: str
    user_id: str
    platform: str
    status: str
    webhook_url: Optional[str] = None
    created_at: str
    last_sync: Optional[str] = None
    sync_count: int = 0
    error_count: int = 0
    message: Optional[str] = None

class IntegrationListResponse(BaseModel):
    """Response model for integration list"""
    integrations: List[Dict[str, Any]]
    total: int

class IntegrationTriggerRequest(BaseModel):
    """Request model for triggering integration"""
    event_type: str = Field(..., description="Event type to trigger")
    data: Dict[str, Any] = Field(..., description="Event data payload")

class WebhookEventResponse(BaseModel):
    """Response model for webhook events"""
    status: str
    platform: str
    event_type: Optional[str] = None
    timestamp: str
```

***

**This completes Part 5B & 5C - Integrations**

**What's Implemented**:
1. âœ… GitHub Connector (Complete with PR, Issues, Reviews)
2. âœ… Notion Connector (Complete with Pages, Databases, Blocks)
3. âœ… Jira Connector (Complete with Issues, JQL, Workflows)
4. âœ… Integration API Endpoints (Full CRUD + Webhooks)
5. âœ… Webhook handling system
6. âœ… Event queue processing

**Next Steps**:
- **Part 6**: Monitoring & Observability (Prometheus + Grafana)
- **Part 7**: Frontend Complete Integration
- **Part 8**: Production Deployment Configuration
- **Part 9**: Testing Strategy
- **Part 10**: Final Production Checklist
