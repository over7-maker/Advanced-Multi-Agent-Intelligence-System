---
description: Docker Compose Production Stack - Complete production stack with all services, resource limits, health checks, and monitoring
globs:
  - "docker-compose.prod.yml"
  - "docker-compose*.yml"
alwaysApply: false
---

# Docker Compose Production Rules

When creating production Docker Compose configurations:

## Complete Stack Structure

1. **Backend service with all configurations**:
   ```yaml
   # ✅ CORRECT: Complete backend configuration
   amas-backend:
     build:
       context: .
       dockerfile: Dockerfile
       args:
         - BUILD_DATE=${BUILD_DATE}
         - VERSION=${VERSION:-1.0.0}
     image: amas-backend:${VERSION:-latest}
     container_name: amas-backend
     restart: unless-stopped
     environment:
       - ENVIRONMENT=production
       - DATABASE_URL=postgresql://amas:${DB_PASSWORD}@postgres:5432/amas
       - REDIS_URL=redis://:${REDIS_PASSWORD}@redis:6379/0
       - NEO4J_URI=bolt://neo4j:7687
       # ... all 16 AI provider keys
       # ... integration credentials
     volumes:
       - amas-logs:/app/logs
       - amas-data:/app/data
     networks:
       - amas-backend
       - amas-monitoring
     depends_on:
       postgres:
         condition: service_healthy
       redis:
         condition: service_healthy
     healthcheck:
       test: ["CMD", "curl", "-f", "http://localhost:8000/health"]
       interval: 30s
       timeout: 10s
       retries: 3
       start_period: 40s
     deploy:
       resources:
         limits:
           cpus: '2'
           memory: 4G
         reservations:
           cpus: '1'
           memory: 2G
   ```

2. **Database services with health checks**:
   ```yaml
   # ✅ CORRECT: PostgreSQL with health check
   postgres:
     image: postgres:15-alpine
     container_name: amas-postgres
     restart: unless-stopped
     environment:
       - POSTGRES_DB=amas
       - POSTGRES_USER=amas
       - POSTGRES_PASSWORD=${DB_PASSWORD}
       - PGDATA=/var/lib/postgresql/data/pgdata
     volumes:
       - postgres-data:/var/lib/postgresql/data
       - ./scripts/init-db.sql:/docker-entrypoint-initdb.d/init.sql
     healthcheck:
       test: ["CMD-SHELL", "pg_isready -U amas -d amas"]
       interval: 10s
       timeout: 5s
       retries: 5
     deploy:
       resources:
         limits:
           cpus: '2'
           memory: 4G
         reservations:
           cpus: '1'
           memory: 2G
   
   # ✅ CORRECT: Redis with persistence
   redis:
     image: redis:7-alpine
     command: >
       redis-server
       --requirepass ${REDIS_PASSWORD}
       --appendonly yes
       --appendfsync everysec
       --maxmemory 2gb
       --maxmemory-policy allkeys-lru
     healthcheck:
       test: ["CMD", "redis-cli", "--raw", "incr", "ping"]
       interval: 10s
       timeout: 5s
       retries: 5
   ```

3. **Monitoring stack**:
   ```yaml
   # ✅ CORRECT: Complete monitoring stack
   prometheus:
     image: prom/prometheus:latest
     command:
       - '--config.file=/etc/prometheus/prometheus.yml'
       - '--storage.tsdb.path=/prometheus'
       - '--storage.tsdb.retention.time=30d'
     volumes:
       - ./monitoring/prometheus/prometheus.yml:/etc/prometheus/prometheus.yml:ro
       - prometheus-data:/prometheus
     networks:
       - amas-monitoring
   
   grafana:
     image: grafana/grafana:latest
     environment:
       - GF_SECURITY_ADMIN_USER=${GRAFANA_USER:-admin}
       - GF_SECURITY_ADMIN_PASSWORD=${GRAFANA_PASSWORD}
       - GF_USERS_ALLOW_SIGN_UP=false
     volumes:
       - ./monitoring/grafana/dashboards:/etc/grafana/provisioning/dashboards:ro
       - grafana-data:/var/lib/grafana
     depends_on:
       - prometheus
   
   jaeger:
     image: jaegertracing/all-in-one:latest
     environment:
       - COLLECTOR_OTLP_ENABLED=true
     networks:
       - amas-monitoring
   
   loki:
     image: grafana/loki:latest
     command: -config.file=/etc/loki/local-config.yaml
     volumes:
       - ./monitoring/loki/config.yml:/etc/loki/local-config.yaml:ro
       - loki-data:/loki
   
   promtail:
     image: grafana/promtail:latest
     volumes:
       - ./monitoring/promtail/config.yml:/etc/promtail/config.yml:ro
       - /var/log:/var/log:ro
       - amas-logs:/app/logs:ro
     depends_on:
       - loki
   ```

4. **Exporters for metrics**:
   ```yaml
   # ✅ CORRECT: Database exporters
   postgres-exporter:
     image: prometheuscommunity/postgres-exporter:latest
     environment:
       - DATA_SOURCE_NAME=postgresql://amas:${DB_PASSWORD}@postgres:5432/amas?sslmode=disable
     networks:
       - amas-backend
       - amas-monitoring
   
   redis-exporter:
     image: oliver006/redis_exporter:latest
     environment:
       - REDIS_ADDR=redis:6379
       - REDIS_PASSWORD=${REDIS_PASSWORD}
     networks:
       - amas-backend
       - amas-monitoring
   ```

## Resource Management

1. **Resource limits**:
   ```yaml
   # ✅ CORRECT: Set resource limits for all services
   deploy:
     resources:
       limits:
         cpus: '2'
         memory: 4G
       reservations:
         cpus: '1'
         memory: 2G
   ```

2. **Network isolation**:
   ```yaml
   # ✅ CORRECT: Separate networks
   networks:
     amas-backend:
       driver: bridge
       ipam:
         config:
           - subnet: 172.20.0.0/16
     amas-monitoring:
       driver: bridge
       ipam:
         config:
           - subnet: 172.21.0.0/16
   ```

3. **Volume management**:
   ```yaml
   # ✅ CORRECT: Named volumes for persistence
   volumes:
     postgres-data:
       driver: local
     redis-data:
       driver: local
     prometheus-data:
       driver: local
     grafana-data:
       driver: local
     amas-logs:
       driver: local
     amas-data:
       driver: local
   ```

## Dependencies and Health Checks

1. **Service dependencies**:
   ```yaml
   # ✅ CORRECT: Use health check conditions
   depends_on:
     postgres:
       condition: service_healthy
     redis:
       condition: service_healthy
   ```

2. **Health check configuration**:
   ```yaml
   # ✅ CORRECT: Comprehensive health checks
   healthcheck:
     test: ["CMD", "curl", "-f", "http://localhost:8000/health"]
     interval: 30s
     timeout: 10s
     retries: 3
     start_period: 40s
   ```

## Environment Variables

1. **Environment file structure**:
   ```bash
   # ✅ CORRECT: Production environment file
   VERSION=1.0.0
   ENVIRONMENT=production
   SECRET_KEY=<32+ char random string>
   JWT_SECRET=<32+ char random string>
   DB_PASSWORD=<strong password>
   REDIS_PASSWORD=<strong password>
   NEO4J_PASSWORD=<strong password>
   # ... all 16 AI provider keys
   # ... integration credentials
   ```

## Best Practices

1. **Always use health checks** - For all services
2. **Set resource limits** - Prevent resource exhaustion
3. **Use named volumes** - For data persistence
4. **Separate networks** - Isolate backend and monitoring
5. **Use depends_on with conditions** - Wait for healthy services
6. **Configure restart policies** - `unless-stopped` for production
7. **Use read-only mounts** - For config files (`:ro`)
8. **Set version tags** - Don't use `latest` in production
9. **Configure logging** - Use proper log drivers
10. **Monitor all services** - Include exporters for metrics
11. **Use secrets management** - Never hardcode passwords
12. **Document all services** - Add comments explaining purpose
