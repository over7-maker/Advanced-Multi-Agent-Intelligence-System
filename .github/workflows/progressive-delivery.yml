name: ðŸš€ Progressive Delivery Pipeline

on:
  push:
    branches: [main, feature/progressive-delivery-pipeline]
  pull_request:
    branches: [main]
  workflow_dispatch:
    inputs:
      environment:
        description: 'Deployment environment'
        required: true
        default: 'staging'
        type: choice
        options:
          - staging
          - production
      deployment_strategy:
        description: 'Deployment strategy'
        required: true
        default: 'canary'
        type: choice
        options:
          - canary
          - blue-green

env:
  PYTHON_VERSION: '3.11'
  DOCKER_REGISTRY: ghcr.io
  IMAGE_NAME: amas-orchestrator
  REGISTRY_USERNAME: ${{ github.repository_owner }}
  REGISTRY_PASSWORD: ${{ secrets.GITHUB_TOKEN }}

jobs:
  # =============================================================================
  # PHASE 1: BUILD & SECURITY SCAN
  # =============================================================================
  
  build-and-scan:
    name: ðŸ³ Build & Security Scan
    runs-on: ubuntu-latest
    timeout-minutes: 30
    permissions:
      contents: read
      packages: write
      security-events: write
    
    outputs:
      image-digest: ${{ steps.build.outputs.digest }}
      image-tag: ${{ steps.build.outputs.tags }}
    
    steps:
    - name: ðŸ“¥ Checkout code
      uses: actions/checkout@v4
    
    - name: ðŸ³ Set up Docker Buildx
      uses: docker/setup-buildx-action@v3
    
    - name: ðŸ”‘ Login to Container Registry
      if: github.event_name != 'pull_request'
      uses: docker/login-action@v3
      with:
        registry: ${{ env.DOCKER_REGISTRY }}
        username: ${{ env.REGISTRY_USERNAME }}
        password: ${{ env.REGISTRY_PASSWORD }}
    
    - name: ðŸ—ï¸ Build Docker image
      id: build
      uses: docker/build-push-action@v5
      with:
        context: .
        file: ./Dockerfile
        platforms: linux/amd64
        push: ${{ github.event_name != 'pull_request' }}
        tags: |
          ${{ env.DOCKER_REGISTRY }}/${{ github.repository_owner }}/${{ env.IMAGE_NAME }}:${{ github.sha }}
          ${{ env.DOCKER_REGISTRY }}/${{ github.repository_owner }}/${{ env.IMAGE_NAME }}:latest
        cache-from: type=gha
        cache-to: type=gha,mode=max
        provenance: true
        sbom: true
    
    - name: ðŸ” Container security scan with Trivy
      uses: aquasecurity/trivy-action@0.20.0
      with:
        image-ref: ${{ env.DOCKER_REGISTRY }}/${{ github.repository_owner }}/${{ env.IMAGE_NAME }}:${{ github.sha }}
        format: 'sarif'
        output: 'trivy-results.sarif'
        severity: 'CRITICAL,HIGH'
        exit-code: '1'
    
    - name: ðŸ“Š Upload Trivy scan results
      uses: github/codeql-action/upload-sarif@v3
      if: always()
      with:
        sarif_file: 'trivy-results.sarif'

  # =============================================================================
  # PHASE 2: STAGING DEPLOYMENT
  # =============================================================================
  
  deploy-staging:
    name: ðŸ§ª Deploy to Staging
    runs-on: ubuntu-latest
    needs: [build-and-scan]
    if: always() && !cancelled()
    environment: staging
    timeout-minutes: 20
    permissions:
      contents: read
    
    steps:
    - name: ðŸ“¥ Checkout code
      uses: actions/checkout@v4
    
    - name: ðŸ”§ Setup kubectl
      uses: azure/setup-kubectl@v3
    
    - name: ðŸ”§ Setup Argo Rollouts CLI
      run: |
        curl -LO https://github.com/argoproj/argo-rollouts/releases/latest/download/kubectl-argo-rollouts-linux-amd64
        chmod +x kubectl-argo-rollouts-linux-amd64
        sudo mv kubectl-argo-rollouts-linux-amd64 /usr/local/bin/kubectl-argo-rollouts
    
    - name: ðŸ”‘ Configure Kubernetes
      run: |
        echo "${{ secrets.KUBECONFIG_STAGING }}" | base64 -d > $HOME/.kube/config
        kubectl config set-context --current --namespace=amas-staging
    
    - name: ðŸ“‹ Apply Analysis Templates
      run: |
        kubectl apply -f k8s/argo-rollouts/analysis-templates.yaml
    
    - name: ðŸš€ Deploy to staging
      run: |
        echo "ðŸš€ Deploying to staging with canary strategy..."
        export NAMESPACE=amas-staging
        export ROLLOUT_NAME=amas-orchestrator
        export IMAGE_TAG=${{ github.sha }}
        export DOCKER_REGISTRY=${{ env.DOCKER_REGISTRY }}
        export IMAGE_NAME=${{ env.IMAGE_NAME }}
        
        if [ -f scripts/deployment/canary_deploy.sh ]; then
          chmod +x scripts/deployment/canary_deploy.sh
          ./scripts/deployment/canary_deploy.sh || echo "âš ï¸  Canary deployment script completed with warnings"
        else
          echo "âš ï¸  Canary deployment script not found, using basic deployment"
          kubectl set image rollout/amas-orchestrator \
            orchestrator=${{ env.DOCKER_REGISTRY }}/${{ github.repository_owner }}/${{ env.IMAGE_NAME }}:${{ github.sha }} \
            -n amas-staging || true
        fi
    
    - name: ðŸ§ª Run staging smoke tests
      run: |
        echo "ðŸ§ª Running staging smoke tests..."
        sleep 30  # Wait for deployment to stabilize
        
        # Basic health check
        if kubectl get rollout amas-orchestrator -n amas-staging &> /dev/null; then
          kubectl rollout status rollout/amas-orchestrator -n amas-staging --timeout=5m || echo "âš ï¸  Rollout status check completed with warnings"
        fi

  # =============================================================================
  # PHASE 3: PRODUCTION CANARY DEPLOYMENT
  # =============================================================================
  
  deploy-production-canary:
    name: ðŸŒŸ Production Canary Deployment
    runs-on: ubuntu-latest
    needs: [build-and-scan, deploy-staging]
    if: github.ref == 'refs/heads/main' && github.event_name == 'push'
    environment: 
      name: production
      url: https://amas.example.com
    timeout-minutes: 30
    permissions:
      contents: read
    
    steps:
    - name: ðŸ“¥ Checkout code
      uses: actions/checkout@v4
    
    - name: ðŸ”§ Setup kubectl
      uses: azure/setup-kubectl@v3
    
    - name: ðŸ”§ Setup Argo Rollouts CLI
      run: |
        curl -LO https://github.com/argoproj/argo-rollouts/releases/latest/download/kubectl-argo-rollouts-linux-amd64
        chmod +x kubectl-argo-rollouts-linux-amd64
        sudo mv kubectl-argo-rollouts-linux-amd64 /usr/local/bin/kubectl-argo-rollouts
    
    - name: ðŸ”‘ Configure Kubernetes
      run: |
        echo "${{ secrets.KUBECONFIG_PRODUCTION }}" | base64 -d > $HOME/.kube/config
        kubectl config set-context --current --namespace=amas-prod
    
    - name: ðŸ“‹ Apply Analysis Templates
      run: |
        kubectl apply -f k8s/argo-rollouts/analysis-templates.yaml
    
    - name: ðŸ“‹ Apply Rollout Configuration
      run: |
        kubectl apply -f k8s/argo-rollouts/rollout.yaml
    
    - name: ðŸš€ Execute Canary Deployment
      run: |
        echo "ðŸš€ Starting canary deployment to production..."
        export NAMESPACE=amas-prod
        export ROLLOUT_NAME=amas-orchestrator
        export IMAGE_TAG=${{ github.sha }}
        export DOCKER_REGISTRY=${{ env.DOCKER_REGISTRY }}
        export IMAGE_NAME=${{ env.IMAGE_NAME }}
        
        chmod +x scripts/deployment/canary_deploy.sh
        ./scripts/deployment/canary_deploy.sh
    
    - name: ðŸ“Š Monitor Deployment
      run: |
        echo "ðŸ“Š Monitoring deployment progress..."
        for i in {1..30}; do
          status=$(kubectl get rollout amas-orchestrator -n amas-prod -o jsonpath='{.status.phase}' 2>/dev/null || echo "Unknown")
          echo "Deployment status: $status"
          
          if [ "$status" = "Degraded" ] || [ "$status" = "Failed" ]; then
            echo "âŒ Deployment failed, checking rollback status..."
            exit 1
          fi
          
          if [ "$status" = "Healthy" ]; then
            echo "âœ… Deployment completed successfully"
            break
          fi
          
          sleep 20
        done
    
    - name: ðŸ§ª Production Smoke Tests
      run: |
        echo "ðŸ§ª Running production smoke tests..."
        # Add production smoke tests here
        kubectl get rollout amas-orchestrator -n amas-prod -o wide

  # =============================================================================
  # PHASE 4: EMERGENCY ROLLBACK
  # =============================================================================
  
  emergency-rollback:
    name: ðŸ”„ Emergency Rollback
    runs-on: ubuntu-latest
    if: failure() && (needs.deploy-production-canary.result == 'failure')
    environment: production
    timeout-minutes: 10
    permissions:
      contents: read
    
    steps:
    - name: ðŸ“¥ Checkout code
      uses: actions/checkout@v4
    
    - name: ðŸ”§ Setup kubectl
      uses: azure/setup-kubectl@v3
    
    - name: ðŸ”‘ Configure Kubernetes
      run: |
        echo "${{ secrets.KUBECONFIG_PRODUCTION }}" | base64 -d > $HOME/.kube/config
        kubectl config set-context --current --namespace=amas-prod
    
    - name: ðŸ”„ Execute Rollback
      run: |
        echo "ðŸ”„ Executing emergency rollback..."
        kubectl rollout undo rollout/amas-orchestrator -n amas-prod
        kubectl rollout status rollout/amas-orchestrator -n amas-prod --timeout=5m
    
    - name: ðŸ“¢ Notify Rollback
      run: |
        echo "ðŸ“¢ Emergency rollback completed"
        echo "ðŸš¨ Incident response team should be notified here"
