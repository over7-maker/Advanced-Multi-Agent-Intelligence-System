name: Progressive Delivery Pipeline

# =============================================================================
# WORKFLOW TRIGGERS
# =============================================================================
# This workflow runs on:
# - Pushes to main and feature/progressive-delivery-pipeline branches
# - Pull requests targeting main or feature/progressive-delivery-pipeline
# - Manual workflow dispatch with environment and strategy selection
# =============================================================================
on:
  push:
    branches: [main, feature/progressive-delivery-pipeline]
  pull_request:
    branches: [main, feature/progressive-delivery-pipeline]
  workflow_dispatch:
    inputs:
      environment:
        description: 'Deployment environment'
        required: true
        default: 'staging'
        type: choice
        options:
          - staging
          - production
      deployment_strategy:
        description: 'Deployment strategy'
        required: true
        default: 'canary'
        type: choice
        options:
          - canary
          - blue-green

# =============================================================================
# GLOBAL ENVIRONMENT VARIABLES (Non-sensitive)
# =============================================================================
# These non-sensitive variables are used across all jobs in the workflow
# Security: Sensitive values (REGISTRY_PASSWORD) are defined at job-level to limit exposure
# =============================================================================
env:
  PYTHON_VERSION: '3.11'
  DOCKER_REGISTRY: ghcr.io
  IMAGE_NAME: amas-orchestrator
  REGISTRY_USERNAME: ${{ github.repository_owner }}

jobs:
  # =============================================================================
  # PHASE 0: INPUT VALIDATION (for workflow_dispatch)
  # =============================================================================
  # Validates workflow inputs before proceeding with any deployment
  # =============================================================================
  
  validate-inputs:
    name: âœ… Validate Workflow Inputs
    runs-on: ubuntu-latest
    timeout-minutes: 5  # Quick validation job
    if: github.event_name == 'workflow_dispatch'
    steps:
    - name: âœ… Validate environment input
      run: |
        ENV="${{ github.event.inputs.environment }}"
        if [[ "$ENV" != "staging" && "$ENV" != "production" ]]; then
          echo "âŒ Invalid environment input: $ENV"
          echo "Must be 'staging' or 'production'"
          exit 1
        fi
        echo "âœ… Environment input valid: $ENV"
    
    - name: âœ… Validate deployment strategy input
      run: |
        STRATEGY="${{ github.event.inputs.deployment_strategy }}"
        if [[ "$STRATEGY" != "canary" && "$STRATEGY" != "blue-green" ]]; then
          echo "âŒ Invalid deployment strategy: $STRATEGY"
          echo "Must be 'canary' or 'blue-green'"
          exit 1
        fi
        echo "âœ… Deployment strategy input valid: $STRATEGY"
    
    - name: âœ… All inputs validated
      run: |
        echo "âœ… All workflow inputs are valid"
        echo "Environment: ${{ github.event.inputs.environment }}"
        echo "Strategy: ${{ github.event.inputs.deployment_strategy }}"

  # =============================================================================
  # PHASE 1: BUILD & SECURITY SCAN
  # =============================================================================
  
  build-and-security-scan:
    name: ðŸ³ Build & Security Scan
    runs-on: ubuntu-latest
    # Run validation first if workflow_dispatch, otherwise skip it
    needs: [validate-inputs]
    if: always() && (needs.validate-inputs.result == 'success' || needs.validate-inputs.result == 'skipped' || github.event_name != 'workflow_dispatch')
    timeout-minutes: 45  # Increased timeout for complex builds
    # Minimal permissions following principle of least privilege
    permissions:
      contents: read      # Read repository contents
      packages: write     # Push container images to GHCR
      security-events: write  # Upload security scan results
    
    # Security: Define sensitive values at job-level, not globally
    # Use GITHUB_TOKEN for GHCR (automatically scoped to repository)
    # For production, consider using secrets.PROD_GHCR_TOKEN with limited permissions
    env:
      REGISTRY_PASSWORD: ${{ secrets.GITHUB_TOKEN }}
    
    outputs:
      image-digest: ${{ steps.build.outputs.digest }}
      image-tag: ${{ steps.build.outputs.tags }}
      image-full: ${{ env.DOCKER_REGISTRY }}/${{ github.repository_owner }}/${{ env.IMAGE_NAME }}:${{ github.sha }}
    
    steps:
    # ========================================================================
    # STEP 1: Checkout source code
    # ========================================================================
    - name: ðŸ“¥ Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0  # Fetch full history for better caching
    
    # ========================================================================
    # STEP 1B: Cache Docker build layers (performance optimization)
    # ========================================================================
    # Uses GitHub Actions cache to speed up Docker builds
    # ========================================================================
    - name: ðŸ“¦ Cache Docker build layers
      uses: actions/cache@v4
      with:
        path: /tmp/.buildx-cache
        key: ${{ runner.os }}-buildx-${{ github.sha }}
        restore-keys: |
          ${{ runner.os }}-buildx-
    
    # ========================================================================
    # STEP 2: Set up Docker Buildx for multi-platform builds
    # ========================================================================
    - name: ðŸ³ Set up Docker Buildx
      uses: docker/setup-buildx-action@v3
      with:
        driver-opts: |
          image=moby/buildkit:latest
          network=host
    
    # ========================================================================
    # STEP 3: Authenticate with container registry
    # ========================================================================
    # Only login for non-PR events (PRs don't push images)
    # Uses HTTPS by default for GHCR (GitHub Container Registry)
    # Security: Never log credentials - GitHub Actions masks secrets automatically
    # ========================================================================
    - name: ðŸ”‘ Login to Container Registry
      if: github.event_name != 'pull_request'
      uses: docker/login-action@v3
      with:
        registry: ${{ env.DOCKER_REGISTRY }}
        username: ${{ env.REGISTRY_USERNAME }}
        password: ${{ env.REGISTRY_PASSWORD }}
      # Note: docker/login-action handles secrets securely
      # Never echo or log REGISTRY_PASSWORD - GitHub masks secrets automatically
    
    # ========================================================================
    # STEP 4: Build and push Docker image
    # ========================================================================
    # Uses GitHub Actions cache for faster builds
    # Includes provenance and SBOM for security
    # Note: Docker build-push-action handles retries internally
    # ========================================================================
    - name: ðŸ—ï¸ Build Docker image
      id: build
      uses: docker/build-push-action@v5
      continue-on-error: false
      with:
        context: .
        file: ./Dockerfile
        platforms: linux/amd64
        push: ${{ github.event_name != 'pull_request' }}
        tags: |
          ${{ env.DOCKER_REGISTRY }}/${{ github.repository_owner }}/${{ env.IMAGE_NAME }}:${{ github.sha }}
          ${{ env.DOCKER_REGISTRY }}/${{ github.repository_owner }}/${{ env.IMAGE_NAME }}:latest
        # Use GitHub Actions cache for faster builds
        # Also use local cache if available
        cache-from: |
          type=gha
          type=local,src=/tmp/.buildx-cache
        cache-to: |
          type=gha,mode=max
          type=local,dest=/tmp/.buildx-cache,mode=max
        # Security: Include provenance and SBOM
        provenance: true
        sbom: true
    
    # ========================================================================
    # STEP 5: Security scan with Trivy
    # ========================================================================
    # Scans container image for vulnerabilities
    # Only runs if build succeeded
    # Doesn't fail workflow on vulnerabilities (reports them instead)
    # ========================================================================
    - name: ðŸ” Container security scan with Trivy
      id: trivy-scan
      if: steps.build.outcome == 'success'  # Only scan if build succeeded
      continue-on-error: true  # Don't fail build on vulnerabilities, but still report them
      uses: aquasecurity/trivy-action@0.20.0
      with:
        image-ref: ${{ env.DOCKER_REGISTRY }}/${{ github.repository_owner }}/${{ env.IMAGE_NAME }}:${{ github.sha }}
        format: 'sarif'
        output: 'trivy-results.sarif'
        severity: 'CRITICAL,HIGH'
        exit-code: '0'  # Don't exit with error code, we'll handle it separately
    
    # ========================================================================
    # STEP 6: Upload security scan results to GitHub Security
    # ========================================================================
    # Uploads SARIF file for security analysis in GitHub
    # Only uploads if scan succeeded and file exists
    # ========================================================================
    - name: ðŸ“Š Upload Trivy scan results
      if: always() && steps.trivy-scan.outcome == 'success' && steps.build.outcome == 'success'
      uses: github/codeql-action/upload-sarif@v3
      continue-on-error: true
      with:
        sarif_file: 'trivy-results.sarif'
    
    # ========================================================================
    # STEP 7: Report security scan status
    # ========================================================================
    # Provides clear status about security scan results
    # ========================================================================
    - name: âš ï¸ Report security scan status
      if: always()
      run: |
        if [ "${{ steps.build.outcome }}" != "success" ]; then
          echo "âš ï¸  Build failed, skipping security scan"
          exit 0
        fi
        
        if [ "${{ steps.trivy-scan.outcome }}" == "skipped" ]; then
          echo "âš ï¸  Security scan was skipped (build may have failed)"
          exit 0
        fi
        
        if [ -f trivy-results.sarif ]; then
          echo "âœ… Security scan completed and results available"
          if [ "${{ steps.trivy-scan.outcome }}" == "success" ]; then
            echo "âœ… SARIF file uploaded successfully"
          else
            echo "âš ï¸  Security scan found issues but results are available"
          fi
        else
          echo "âš ï¸  Security scan did not produce SARIF file"
          if [ "${{ steps.trivy-scan.outcome }}" != "success" ]; then
            echo "âŒ Trivy scan failed - check logs above for details"
            echo "This may happen if the image doesn't exist or Trivy encountered an error"
          fi
        fi

  # =============================================================================
  # PHASE 2: STAGING DEPLOYMENT
  # =============================================================================
  # Deploys to staging environment for testing before production
  # Uses canary or blue-green strategy based on configuration
  # Gracefully handles missing resources (staging may not be fully configured)
  # =============================================================================
  
  deploy-staging:
    name: ðŸ§ª Deploy to Staging
    runs-on: ubuntu-latest
    needs: [build-and-security-scan]
    if: always() && !cancelled() && needs.build-and-security-scan.result != 'failure'
    environment: staging
    timeout-minutes: 20
    # Minimal permissions: only read contents (no write access needed)
    permissions:
      contents: read
    continue-on-error: true  # Don't fail entire workflow if staging deployment fails
    
    steps:
    # ========================================================================
    # STEP 1: Checkout code
    # ========================================================================
    - name: ðŸ“¥ Checkout code
      uses: actions/checkout@v4
    
    # ========================================================================
    # STEP 2: Install kubectl for Kubernetes operations
    # ========================================================================
    - name: ðŸ”§ Setup kubectl
      uses: azure/setup-kubectl@v3
    
    # ========================================================================
    # STEP 3: Install Argo Rollouts CLI for canary deployments
    # ========================================================================
    - name: ðŸ”§ Setup Argo Rollouts CLI
      run: |
        curl -LO https://github.com/argoproj/argo-rollouts/releases/latest/download/kubectl-argo-rollouts-linux-amd64
        chmod +x kubectl-argo-rollouts-linux-amd64
        sudo mv kubectl-argo-rollouts-linux-amd64 /usr/local/bin/kubectl-argo-rollouts
    
    - name: ðŸ”‘ Configure Kubernetes
      run: |
        if [ -z "${{ secrets.KUBECONFIG_STAGING }}" ]; then
          echo "âš ï¸  KUBECONFIG_STAGING secret not set, skipping staging deployment"
          echo "This is expected if staging cluster is not configured yet"
          exit 0
        fi
        
        echo "${{ secrets.KUBECONFIG_STAGING }}" | base64 -d > $HOME/.kube/config || {
          echo "âŒ Failed to decode KUBECONFIG_STAGING"
          exit 1
        }
        
        # Verify kubectl works
        kubectl version --client || {
          echo "âŒ kubectl not working"
          exit 1
        }
        
        # Create namespace if it doesn't exist
        kubectl create namespace amas-staging --dry-run=client -o yaml | kubectl apply -f - || true
        kubectl config set-context --current --namespace=amas-staging
    
    - name: ðŸ“‹ Check Argo Rollouts Installation
      run: |
        if ! kubectl get crd rollouts.argoproj.io &> /dev/null; then
          echo "âš ï¸  Argo Rollouts CRD not found in staging cluster"
          echo "âš ï¸  Skipping Argo Rollouts deployment, using standard Kubernetes deployment"
          echo "SKIP_ARGO_ROLLOUTS=true" >> $GITHUB_ENV
        else
          echo "âœ… Argo Rollouts is installed"
          echo "SKIP_ARGO_ROLLOUTS=false" >> $GITHUB_ENV
        fi
    
    - name: ðŸ“‹ Apply Analysis Templates
      if: env.SKIP_ARGO_ROLLOUTS == 'false'
      run: |
        # Update namespace in analysis templates for staging
        sed 's/namespace: amas-prod/namespace: amas-staging/g' k8s/argo-rollouts/analysis-templates.yaml | \
          kubectl apply -f - || {
          echo "âš ï¸  Failed to apply analysis templates (may not exist in staging)"
        }
    
    - name: ðŸš€ Deploy to staging
      run: |
        echo "ðŸš€ Deploying to staging..."
        export NAMESPACE=amas-staging
        export ROLLOUT_NAME=amas-orchestrator
        export IMAGE_TAG=${{ github.sha }}
        export DOCKER_REGISTRY=${{ env.DOCKER_REGISTRY }}
        export IMAGE_NAME=${{ env.IMAGE_NAME }}
        export FULL_IMAGE="${DOCKER_REGISTRY}/${{ github.repository_owner }}/${IMAGE_NAME}:${IMAGE_TAG}"
        
        # Security: Only log image name, never credentials
        echo "Deploying image: $FULL_IMAGE"
        
        # Check if rollout exists
        if kubectl get rollout amas-orchestrator -n amas-staging &> /dev/null; then
          echo "âœ… Rollout exists, updating image..."
          
          if [ "$SKIP_ARGO_ROLLOUTS" = "false" ] && [ -f scripts/deployment/canary_deploy.sh ]; then
            echo "ðŸš€ Using canary deployment strategy..."
            chmod +x scripts/deployment/canary_deploy.sh
            export ROLLOUT_NAME=amas-orchestrator
            ./scripts/deployment/canary_deploy.sh || {
              echo "âš ï¸  Canary deployment failed, trying basic update..."
              kubectl set image rollout/amas-orchestrator \
                orchestrator="$FULL_IMAGE" \
                -n amas-staging || true
            }
          else
            echo "ðŸš€ Using standard rollout update..."
            kubectl set image rollout/amas-orchestrator \
              orchestrator="$FULL_IMAGE" \
              -n amas-staging || {
              echo "âŒ Failed to update rollout"
              exit 1
            }
          fi
        elif kubectl get deployment amas-orchestrator -n amas-staging &> /dev/null; then
          echo "âœ… Standard deployment exists, updating image..."
          kubectl set image deployment/amas-orchestrator \
            orchestrator="$FULL_IMAGE" \
            -n amas-staging || {
            echo "âŒ Failed to update deployment"
            exit 1
          }
        else
          echo "âš ï¸  No rollout or deployment found in staging"
          echo "âš ï¸  This is expected if staging environment is not fully set up"
          echo "âš ï¸  Skipping deployment (this is not a failure)"
          exit 0
        fi
    
    - name: ðŸ§ª Run staging smoke tests
      run: |
        echo "ðŸ§ª Running staging smoke tests..."
        sleep 30  # Wait for deployment to stabilize
        
        # Check rollout status
        if kubectl get rollout amas-orchestrator -n amas-staging &> /dev/null; then
          echo "ðŸ“Š Checking rollout status..."
          kubectl rollout status rollout/amas-orchestrator -n amas-staging --timeout=5m || {
            echo "âš ï¸  Rollout status check completed with warnings"
            # Don't fail the job, just warn
          }
        elif kubectl get deployment amas-orchestrator -n amas-staging &> /dev/null; then
          echo "ðŸ“Š Checking deployment status..."
          kubectl rollout status deployment/amas-orchestrator -n amas-staging --timeout=5m || {
            echo "âš ï¸  Deployment status check completed with warnings"
          }
        else
          echo "âš ï¸  No deployment found, skipping status check"
        fi
        
        echo "âœ… Staging deployment check completed"

  # =============================================================================
  # PHASE 3: PRODUCTION CANARY DEPLOYMENT
  # =============================================================================
  
  deploy-production-canary:
    name: ðŸŒŸ Production Canary Deployment
    runs-on: ubuntu-latest
    needs: [build-and-security-scan, deploy-staging]
    # Only run canary deployment if:
    # - On main branch push, OR
    # - Manual dispatch with canary strategy selected
    if: |
      needs.build-and-security-scan.result == 'success' && (
        (github.ref == 'refs/heads/main' && github.event_name == 'push') ||
        (github.event_name == 'workflow_dispatch' && github.event.inputs.deployment_strategy == 'canary')
      )
    environment: 
      name: production
      url: https://amas.example.com
    timeout-minutes: 30
    permissions:
      contents: read
    
    steps:
    - name: ðŸ“¥ Checkout code
      uses: actions/checkout@v4
    
    - name: ðŸ”§ Setup kubectl
      uses: azure/setup-kubectl@v3
    
    - name: ðŸ”§ Setup Argo Rollouts CLI
      run: |
        curl -LO https://github.com/argoproj/argo-rollouts/releases/latest/download/kubectl-argo-rollouts-linux-amd64
        chmod +x kubectl-argo-rollouts-linux-amd64
        sudo mv kubectl-argo-rollouts-linux-amd64 /usr/local/bin/kubectl-argo-rollouts
    
    - name: ðŸ”‘ Configure Kubernetes
      run: |
        echo "${{ secrets.KUBECONFIG_PRODUCTION }}" | base64 -d > $HOME/.kube/config
        kubectl config set-context --current --namespace=amas-prod
    
    - name: ðŸ“‹ Apply Analysis Templates
      run: |
        kubectl apply -f k8s/argo-rollouts/analysis-templates.yaml
    
    - name: ðŸ“‹ Apply Rollout Configuration
      run: |
        kubectl apply -f k8s/argo-rollouts/rollout.yaml
    
    - name: ðŸš€ Execute Canary Deployment
      run: |
        echo "ðŸš€ Starting canary deployment to production..."
        export NAMESPACE=amas-prod
        export ROLLOUT_NAME=amas-orchestrator
        export IMAGE_TAG=${{ github.sha }}
        export DOCKER_REGISTRY=${{ env.DOCKER_REGISTRY }}
        export IMAGE_NAME=${{ env.IMAGE_NAME }}
        
        chmod +x scripts/deployment/canary_deploy.sh
        ./scripts/deployment/canary_deploy.sh
    
    - name: ðŸ“Š Monitor Deployment
      run: |
        echo "ðŸ“Š Monitoring deployment progress..."
        for i in {1..30}; do
          status=$(kubectl get rollout amas-orchestrator -n amas-prod -o jsonpath='{.status.phase}' 2>/dev/null || echo "Unknown")
          echo "Deployment status: $status"
          
          if [ "$status" = "Degraded" ] || [ "$status" = "Failed" ]; then
            echo "âŒ Deployment failed, checking rollback status..."
            exit 1
          fi
          
          if [ "$status" = "Healthy" ]; then
            echo "âœ… Deployment completed successfully"
            break
          fi
          
          sleep 20
        done
    
    - name: ðŸ§ª Production Smoke Tests
      run: |
        echo "ðŸ§ª Running production smoke tests..."
        # Add production smoke tests here
        kubectl get rollout amas-orchestrator -n amas-prod -o wide

  # =============================================================================
  # PHASE 3B: PRODUCTION BLUE-GREEN DEPLOYMENT
  # =============================================================================
  # Alternative deployment strategy for emergency scenarios
  # =============================================================================
  
  deploy-production-blue-green:
    name: ðŸ”µ Production Blue-Green Deployment
    runs-on: ubuntu-latest
    needs: [build-and-security-scan, deploy-staging]
    # Only run blue-green deployment if manually selected
    if: |
      needs.build-and-security-scan.result == 'success' && (
        github.event_name == 'workflow_dispatch' && 
        github.event.inputs.deployment_strategy == 'blue-green'
      )
    environment: 
      name: production
      url: https://amas.example.com
    timeout-minutes: 20  # Blue-green is faster (instant switch)
    permissions:
      contents: read
    
    steps:
    - name: ðŸ“¥ Checkout code
      uses: actions/checkout@v4
    
    - name: ðŸ”§ Setup kubectl
      uses: azure/setup-kubectl@v3
    
    - name: ðŸ”‘ Configure Kubernetes
      run: |
        echo "${{ secrets.KUBECONFIG_PRODUCTION }}" | base64 -d > $HOME/.kube/config
        kubectl config set-context --current --namespace=amas-prod
    
    - name: ðŸš€ Execute Blue-Green Deployment
      run: |
        echo "ðŸš€ Starting blue-green deployment to production..."
        export NAMESPACE=amas-prod
        export SERVICE_NAME=amas-orchestrator
        export IMAGE_TAG=${{ github.sha }}
        export DOCKER_REGISTRY=${{ env.DOCKER_REGISTRY }}
        export IMAGE_NAME=${{ env.IMAGE_NAME }}
        
        if [ -f scripts/deployment/blue_green_deploy.sh ]; then
          chmod +x scripts/deployment/blue_green_deploy.sh
          ./scripts/deployment/blue_green_deploy.sh deploy
        else
          echo "âš ï¸  Blue-green deployment script not found"
          exit 1
        fi
    
    - name: ðŸ§ª Production Smoke Tests
      run: |
        echo "ðŸ§ª Running production smoke tests..."
        kubectl get deployments -n amas-prod -l "app=amas-orchestrator" -o wide

  # =============================================================================
  # PHASE 4: EMERGENCY ROLLBACK
  # =============================================================================
  
  emergency-rollback:
    name: ðŸ”„ Emergency Rollback
    runs-on: ubuntu-latest
    # Trigger rollback if either deployment strategy fails
    if: |
      failure() && (
        (needs.deploy-production-canary.result == 'failure') ||
        (needs.deploy-production-blue-green.result == 'failure')
      )
    environment: production
    timeout-minutes: 10
    permissions:
      contents: read
    
    steps:
    - name: ðŸ“¥ Checkout code
      uses: actions/checkout@v4
    
    - name: ðŸ”§ Setup kubectl
      uses: azure/setup-kubectl@v3
    
    - name: ðŸ”‘ Configure Kubernetes
      run: |
        echo "${{ secrets.KUBECONFIG_PRODUCTION }}" | base64 -d > $HOME/.kube/config
        kubectl config set-context --current --namespace=amas-prod
    
    - name: ðŸ”„ Execute Rollback
      run: |
        echo "ðŸ”„ Executing emergency rollback..."
        kubectl rollout undo rollout/amas-orchestrator -n amas-prod
        kubectl rollout status rollout/amas-orchestrator -n amas-prod --timeout=5m
    
    - name: ðŸ“¢ Notify Rollback
      run: |
        echo "ðŸ“¢ Emergency rollback completed"
        echo "ðŸš¨ Incident response team should be notified here"
