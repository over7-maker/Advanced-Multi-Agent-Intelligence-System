name: Progressive Delivery Pipeline

# =============================================================================
# PROGRESSIVE DELIVERY PIPELINE WORKFLOW
# =============================================================================
# Purpose: Safe, automated deployments with canary releases, SLO-based gates,
#          automatic rollback, and zero-downtime delivery.
#
# Security: Only merged PRs trigger production deployment (not direct pushes).
#           Branch protection validation ensures code review and status checks.
#           Production environment requires manual approval.
#
# Triggers:
#   - PR merged to main: Production deployment (validated merge + branch protection)
#   - PR opened/updated: Build and test only (no deployment)
#   - Manual dispatch: Deploy with environment/strategy selection
#
# See docs/deployment/PROGRESSIVE_DELIVERY.md for detailed documentation.
# =============================================================================
on:
  # Production deployment: Only trigger on merged PRs to main (not direct pushes)
  # Security: Ensures code review and branch protection are enforced
  # PR testing: Build and test on PR updates (doesn't deploy)
  pull_request:
    branches:
      - main
      - feature/progressive-delivery-pipeline
    # Trigger on PR updates for testing, and on PR close for deployment validation
    types: [opened, synchronize, reopened, ready_for_review, closed]
  workflow_dispatch:
    inputs:
      environment:
        description: 'Deployment environment'
        required: true
        default: 'staging'
        type: choice
        options:
          - staging
          - production
      deployment_strategy:
        description: |
          Deployment strategy selection:
          - canary: Progressive rollout (10%‚Üí25%‚Üí50%‚Üí75%‚Üí100%)
          - blue-green: Instant traffic switch for emergencies
        required: true
        default: 'canary'
        type: choice
        options:
          - canary
          - blue-green
      image_name:
        description: |
          Container image name (optional).
          Must be 1-255 chars, alphanumeric with hyphens/dots/underscores.
        required: false
        default: 'amas-orchestrator'
        type: string
      docker_registry:
        description: |
          Docker registry hostname (optional).
          Examples: ghcr.io, registry.example.com:5000
        required: false
        default: 'ghcr.io'
        type: string

# =============================================================================
# CONCURRENCY CONTROL
# =============================================================================
# Prevents multiple deployments from running simultaneously on the same branch
# Security: Prevents race conditions and conflicting deployments
# =============================================================================
concurrency:
  group: progressive-delivery-${{ github.ref }}
  cancel-in-progress: false  # Don't cancel deployments in progress (safety)

# =============================================================================
# WORKFLOW-LEVEL PERMISSIONS
# =============================================================================
# Minimal permissions following principle of least privilege
# Individual jobs can override if needed
# Security: Explicitly set permissions to minimum required
# =============================================================================
permissions:
  contents: read      # Read repository contents (for checkout)
  packages: write     # Push container images to GHCR
  security-events: write  # Upload security scan results (SARIF)
  actions: read       # Read workflow status (for job dependencies)

# =============================================================================
# WORKFLOW DEFAULTS
# =============================================================================
# Set default shell and timeout for all jobs
# Security: Use bash explicitly to avoid shell injection risks
# Performance: Set reasonable timeouts to prevent resource exhaustion
# =============================================================================
defaults:
  run:
    shell: bash
    # Default timeout for all run steps (can be overridden per job)
    timeout-minutes: 10

# =============================================================================
# GLOBAL ENVIRONMENT VARIABLES (Non-sensitive)
# =============================================================================
# These non-sensitive variables are used across all jobs in the workflow
# Security: Sensitive values (REGISTRY_PASSWORD) are defined at job-level to limit exposure
# Note: Image name and registry can be overridden via workflow_dispatch inputs
# =============================================================================
env:
  PYTHON_VERSION: '3.11'
  # Use inputs if provided, otherwise defaults (can be overridden per job if needed)
  DOCKER_REGISTRY: ${{ github.event.inputs.docker_registry || 'ghcr.io' }}
  IMAGE_NAME: ${{ github.event.inputs.image_name || 'amas-orchestrator' }}
  REGISTRY_USERNAME: ${{ github.repository_owner }}
  # Performance: Enable Docker BuildKit for faster builds
  DOCKER_BUILDKIT: 1
  BUILDKIT_INLINE_CACHE: 1

# =============================================================================
# JOBS DEFINITION
# =============================================================================
# Phases: 0=Input Validation, 1=Build & Scan, 2=Staging, 
#         3=Production Canary, 3B=Production Blue-Green, 
#         4=Emergency Rollback, 5=Failure Notifications
# =============================================================================

jobs:
  # =============================================================================
  # PHASE -1: BRANCH PROTECTION VALIDATION
  # =============================================================================
  # Purpose: Validates that branch protection rules are enabled for main branch
  # Security: Prevents deployment of unreviewed/untested code
  # Note: This job only runs on push to main (not on PRs)
  # =============================================================================
  
  validate-pr-merge:
    name: üõ°Ô∏è Validate PR Merge
    runs-on: ubuntu-latest
    # Only validate on closed PRs to main (check if merged)
    if: github.event_name == 'pull_request' && github.event.action == 'closed' && github.base_ref == 'main'
    timeout-minutes: 5
    permissions:
      contents: read
      pull-requests: read
    steps:
    - name: üîç Verify PR Was Merged
      run: |
        echo "üîç Validating PR merge status..."
        
        # Check if PR was actually merged (not just closed)
        if [ "${{ github.event.pull_request.merged }}" != "true" ]; then
          echo "‚ö†Ô∏è  PR was closed but not merged, skipping deployment"
          echo "PR #${{ github.event.pull_request.number }} was closed without merge"
          exit 0  # Not an error, just skip deployment
        fi
        
        echo "‚úÖ PR #${{ github.event.pull_request.number }} was successfully merged"
        echo "‚úÖ Merge commit: ${{ github.event.pull_request.merge_commit_sha }}"
        echo "‚úÖ Merged by: ${{ github.event.pull_request.merged_by.login }}"
    
    - name: üîç Check Branch Protection Rules
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      run: |
        echo "üîç Validating branch protection rules for main branch..."
        
        # Get branch protection status
        response=$(curl -s -w "\n%{http_code}" \
          -H "Authorization: Bearer $GITHUB_TOKEN" \
          -H "Accept: application/vnd.github.v3+json" \
          "https://api.github.com/repos/${{ github.repository }}/branches/main/protection")
        
        http_code=$(echo "$response" | tail -n1)
        body=$(echo "$response" | sed '$d')
        
        if [ "$http_code" != "200" ]; then
          echo "‚ùå Branch protection not configured or not accessible"
          echo "HTTP Status: $http_code"
          echo "Response: $body"
          echo ""
          echo "‚ö†Ô∏è  CRITICAL: Branch protection rules must be enabled!"
          echo "Configure in: Settings > Branches > main"
          exit 1
        fi
        
        # Validate required status checks
        if ! echo "$body" | jq -e '.required_status_checks != null' &> /dev/null; then
          echo "‚ùå Required status checks not configured"
          exit 1
        fi
        
        # Validate required pull request reviews
        if ! echo "$body" | jq -e '.required_pull_request_reviews != null' &> /dev/null; then
          echo "‚ùå Required pull request reviews not configured"
          exit 1
        fi
        
        # Validate enforce admins (optional but recommended)
        enforce_admins=$(echo "$body" | jq -r '.enforce_admins.enabled // false')
        if [ "$enforce_admins" != "true" ]; then
          echo "‚ö†Ô∏è  Warning: Enforce admins is not enabled"
          echo "   Recommended: Enable 'Do not allow bypassing the above settings'"
        fi
        
        echo "‚úÖ Branch protection rules validated successfully"
        echo "‚úÖ Required status checks: Enabled"
        echo "‚úÖ Required PR reviews: Enabled"
        echo "‚úÖ Enforce admins: $enforce_admins"
    
    - name: ‚úÖ PR Merge Validated
      run: |
        echo "‚úÖ PR merge validated successfully"
        echo "‚úÖ Branch protection rules verified"
        echo "‚úÖ Safe to proceed with deployment"

  # =============================================================================
  # PHASE 0: INPUT VALIDATION (for workflow_dispatch)
  # =============================================================================
  # Purpose: Validates workflow inputs before proceeding with any deployment
  # Security: Validates format and length to prevent injection attacks
  #          - Environment: staging or production only
  #          - Strategy: canary or blue-green only
  #          - Image name: 1-255 chars, alphanumeric with hyphens/dots/underscores
  #          - Registry: 1-253 chars, valid hostname format
  # =============================================================================
  
  validate-inputs:
    name: ‚úÖ Validate Workflow Inputs
    runs-on: ubuntu-latest
    timeout-minutes: 5  # Quick validation job
    if: github.event_name == 'workflow_dispatch'
    steps:
    - name: ‚úÖ Validate environment input
      run: |
        ENV="${{ github.event.inputs.environment }}"
        if [[ -z "$ENV" ]]; then
          echo "‚ùå Environment input is required"
          exit 1
        fi
        if [[ "$ENV" != "staging" && "$ENV" != "production" ]]; then
          echo "‚ùå Invalid environment input: $ENV"
          echo "Must be 'staging' or 'production'"
          exit 1
        fi
        echo "‚úÖ Environment input valid: $ENV"
        echo "ENVIRONMENT=$ENV" >> $GITHUB_ENV
    
    - name: ‚úÖ Validate deployment strategy input
      run: |
        STRATEGY="${{ github.event.inputs.deployment_strategy }}"
        if [[ -z "$STRATEGY" ]]; then
          echo "‚ùå Deployment strategy input is required"
          exit 1
        fi
        if [[ "$STRATEGY" != "canary" && "$STRATEGY" != "blue-green" ]]; then
          echo "‚ùå Invalid deployment strategy: $STRATEGY"
          echo "Must be 'canary' or 'blue-green'"
          exit 1
        fi
        echo "‚úÖ Deployment strategy input valid: $STRATEGY"
        echo "DEPLOYMENT_STRATEGY=$STRATEGY" >> $GITHUB_ENV
    
    - name: ‚úÖ Validate optional inputs
      run: |
        # ===================================================================
        # Validate image name if provided
        # Security: Prevent injection attacks by strict format validation
        # ===================================================================
        IMAGE_NAME="${{ github.event.inputs.image_name }}"
        if [[ -n "$IMAGE_NAME" ]]; then
          # Validate length (1-255 characters)
          if [[ ${#IMAGE_NAME} -lt 1 ]] || [[ ${#IMAGE_NAME} -gt 255 ]]; then
            echo "‚ùå Invalid image name length: $IMAGE_NAME"
            echo "Image name must be 1-255 characters"
            exit 1
          fi
          
          # Validate format: alphanumeric, hyphens, dots, underscores, slashes
          # Must start and end with alphanumeric
          if [[ ! "$IMAGE_NAME" =~ ^[a-z0-9]([-._/a-z0-9]*[a-z0-9])?$ ]]; then
            echo "‚ùå Invalid image name format: $IMAGE_NAME"
            echo "Image name must be alphanumeric with hyphens, dots, underscores, or slashes"
            exit 1
          fi
          
          echo "‚úÖ Image name format valid: $IMAGE_NAME"
        fi
        
        # ===================================================================
        # Validate registry if provided
        # Security: Prevent injection attacks by strict hostname validation
        # ===================================================================
        REGISTRY="${{ github.event.inputs.docker_registry }}"
        if [[ -n "$REGISTRY" ]]; then
          # Validate length (1-253 characters per RFC 1123)
          if [[ ${#REGISTRY} -lt 1 ]] || [[ ${#REGISTRY} -gt 253 ]]; then
            echo "‚ùå Invalid registry length: $REGISTRY"
            echo "Registry must be 1-253 characters"
            exit 1
          fi
          
          # Validate format: hostname or hostname:port (no protocol)
          # Pattern: alphanumeric with hyphens, dots, optional port
          if [[ ! "$REGISTRY" =~ ^[a-z0-9]([-a-z0-9]*[a-z0-9])?(\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*(:[0-9]+)?$ ]]; then
            echo "‚ùå Invalid registry format: $REGISTRY"
            echo "Registry must be valid hostname format (e.g., ghcr.io, registry.example.com:5000)"
            exit 1
          fi
          
          echo "‚úÖ Registry format valid: $REGISTRY"
        fi
    
    - name: ‚úÖ All inputs validated
      run: |
        echo "‚úÖ All workflow inputs are valid"
        echo "Environment: ${{ github.event.inputs.environment }}"
        echo "Strategy: ${{ github.event.inputs.deployment_strategy }}"
        echo "Image Name: ${{ github.event.inputs.image_name || 'amas-orchestrator' }}"
        echo "Registry: ${{ github.event.inputs.docker_registry || 'ghcr.io' }}"

  # =============================================================================
  # PHASE 1: BUILD & SECURITY SCAN
  # =============================================================================
  # Purpose: Builds Docker container image and performs security scanning
  # Dependencies: validate-inputs (if workflow_dispatch)
  # Outputs: image-digest, image-tag, image-full (used by deployment jobs)
  # Performance: Uses GitHub Actions cache for Docker layers (avoids large downloads)
  # Security: Trivy scans for CRITICAL/HIGH vulnerabilities
  # =============================================================================
  
  build-and-security-scan:
    name: üê≥ Build & Security Scan
    runs-on: ubuntu-latest
    # Run validation first if workflow_dispatch, otherwise skip it
    # Also validate PR merge on pull_request.closed events
    needs: 
      - validate-inputs
      - validate-pr-merge
    if: |
      always() && 
      (needs.validate-inputs.result == 'success' || needs.validate-inputs.result == 'skipped' || github.event_name != 'workflow_dispatch') &&
      (needs.validate-pr-merge.result == 'success' || needs.validate-pr-merge.result == 'skipped' || github.event_name != 'pull_request' || github.event.action != 'closed')
    timeout-minutes: 45  # Increased timeout for complex builds (accommodates 4.5GB base image downloads)
    # Minimal permissions following principle of least privilege
    permissions:
      contents: read      # Read repository contents
      packages: write     # Push container images to GHCR
      security-events: write  # Upload security scan results
    # Resource limits: Prevent resource exhaustion
    # Note: GitHub Actions runners have default limits, but explicit limits help with planning
    
    # Security: Define sensitive values at job-level, not globally
    # Use GITHUB_TOKEN for GHCR (automatically scoped to repository permissions)
    # For production, consider using secrets.PROD_GHCR_TOKEN with limited permissions
    env:
      REGISTRY_PASSWORD: ${{ secrets.GITHUB_TOKEN }}
    
    outputs:
      image-digest: ${{ steps.build.outputs.digest }}
      image-tag: ${{ steps.build.outputs.tags }}
      image-full: ${{ env.DOCKER_REGISTRY }}/${{ github.repository_owner }}/${{ env.IMAGE_NAME }}:${{ github.sha }}
    
    steps:
    # ========================================================================
    # STEP 1: Checkout source code
    # ========================================================================
    - name: üì• Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0  # Fetch full history for better caching
    
    # ========================================================================
    # STEP 1A: Set up Python (if needed for build scripts)
    # ========================================================================
    # Note: Python dependencies are installed inside Docker container during build
    # This step is only needed if build scripts require Python runtime
    # ========================================================================
    - name: üêç Set up Python (for build scripts if needed)
      if: hashFiles('scripts/**/*.py') != '' || hashFiles('*.py') != ''
      uses: actions/setup-python@v5
      with:
        python-version: ${{ env.PYTHON_VERSION }}
        # Don't cache pip - dependencies installed in Docker, not here
    
    # ========================================================================
    # STEP 2: Set up Docker Buildx for multi-platform builds
    # ========================================================================
    # Note: Docker layer caching is handled by build-push-action using GHA cache
    # Local cache removed to avoid large cache downloads (4.9GB+ issue)
    # ========================================================================
    - name: üê≥ Set up Docker Buildx
      uses: docker/setup-buildx-action@v3
      with:
        driver-opts: |
          image=moby/buildkit:latest
          network=host
    
    # ========================================================================
    # STEP 3: Authenticate with container registry
    # ========================================================================
    # Only login for non-PR events (PRs don't push images)
    # Uses HTTPS by default for GHCR (GitHub Container Registry)
    # Security: Never log credentials - GitHub Actions masks secrets automatically
    # ========================================================================
    - name: üîë Login to Container Registry
      if: github.event_name != 'pull_request'
      uses: docker/login-action@v3
      with:
        registry: ${{ env.DOCKER_REGISTRY }}
        username: ${{ env.REGISTRY_USERNAME }}
        password: ${{ env.REGISTRY_PASSWORD }}
      # Note: docker/login-action handles secrets securely
      # Never echo or log REGISTRY_PASSWORD - GitHub masks secrets automatically
    
    # ========================================================================
    # STEP 3B: Validate build context (for debugging)
    # ========================================================================
    - name: üîç Validate build context
      run: |
        echo "üìã Checking build context..."
        echo "Dockerfile exists: $(test -f Dockerfile && echo 'yes' || echo 'no')"
        echo "requirements.txt exists: $(test -f requirements.txt && echo 'yes' || echo 'no')"
        echo "src/ directory exists: $(test -d src && echo 'yes' || echo 'no')"
        echo "web/ directory exists: $(test -d web && echo 'yes' || echo 'no')"
        echo "main.py exists: $(test -f main.py && echo 'yes' || echo 'no')"
        echo "main_simple.py exists: $(test -f main_simple.py && echo 'yes' || echo 'no')"
        echo "‚úÖ Build context validation complete"
    
    # ========================================================================
    # STEP 4: Build and push Docker image
    # ========================================================================
    # Performance: Uses GHA cache only (avoids large local cache downloads)
    # Security: Includes provenance and SBOM for supply chain security
    # Note: First build may download large base images (python:3.11-slim + nodejs ~4.5GB)
    #       Subsequent builds use cached layers and are much faster
    #       Build timeout is 45 minutes to accommodate first-time large downloads
    # ========================================================================
    - name: üèóÔ∏è Build Docker image
      id: build
      uses: docker/build-push-action@v5
      # For PRs: allow build to fail gracefully (we'll still validate the Dockerfile)
      continue-on-error: ${{ github.event_name == 'pull_request' }}
      # Enable verbose output to see actual build errors
      env:
        DOCKER_BUILDKIT: 1
        BUILDKIT_PROGRESS: plain
      with:
        context: .
        file: ./Dockerfile
        platforms: linux/amd64
        push: ${{ github.event_name != 'pull_request' }}
        tags: |
          ${{ env.DOCKER_REGISTRY }}/${{ github.repository_owner }}/${{ env.IMAGE_NAME }}:${{ github.sha }}
          ${{ env.DOCKER_REGISTRY }}/${{ github.repository_owner }}/${{ env.IMAGE_NAME }}:latest
        # Performance: Use GHA cache only (avoids 4.9GB+ local cache downloads)
        # First build downloads ~4.5GB base images, subsequent builds use cache
        cache-from: type=gha
        cache-to: type=gha,mode=max
        # Security: Include provenance and SBOM (only for pushes, not PRs)
        # Note: Provenance/SBOM require pushing to registry, skip for PR builds
        provenance: ${{ github.event_name != 'pull_request' }}
        sbom: ${{ github.event_name != 'pull_request' }}
    
    # ========================================================================
    # STEP 5: Security scan with Trivy
    # ========================================================================
    # Scans container image for vulnerabilities
    # Only runs if build succeeded
    # Doesn't fail workflow on vulnerabilities (reports them instead)
    # ========================================================================
    - name: üîç Container security scan with Trivy
      id: trivy-scan
      # Only scan for non-PR builds (PRs don't push images, so can't scan from registry)
      # For PRs, security scanning happens after merge when image is pushed
      if: steps.build.outcome == 'success' && github.event_name != 'pull_request'
      continue-on-error: true  # Don't fail build on vulnerabilities, but still report them
      uses: aquasecurity/trivy-action@0.20.0
      with:
        image-ref: ${{ env.DOCKER_REGISTRY }}/${{ github.repository_owner }}/${{ env.IMAGE_NAME }}:${{ github.sha }}
        format: 'sarif'
        output: 'trivy-results.sarif'
        severity: 'CRITICAL,HIGH'
        exit-code: '0'  # Don't exit with error code, we'll handle it separately
    
    # ========================================================================
    # STEP 6: Upload security scan results to GitHub Security
    # ========================================================================
    # Uploads SARIF file for security analysis in GitHub
    # Only uploads if scan succeeded and file exists
    # ========================================================================
    - name: üìä Upload Trivy scan results
      if: always() && steps.trivy-scan.outcome == 'success' && steps.build.outcome == 'success'
      uses: github/codeql-action/upload-sarif@v3
      continue-on-error: true
      with:
        sarif_file: 'trivy-results.sarif'
        # Artifact retention: Security reports retained for 30 days
        retention-days: 30
    
    # ========================================================================
    # STEP 7: Report security scan status
    # ========================================================================
    # Provides clear status about security scan results
    # ========================================================================
    - name: ‚ö†Ô∏è Report security scan status
      if: always()
      run: |
        if [ "${{ steps.build.outcome }}" != "success" ]; then
          echo "‚ö†Ô∏è  Build failed, skipping security scan"
          exit 0
        fi
        
        if [ "${{ steps.trivy-scan.outcome }}" == "skipped" ]; then
          echo "‚ö†Ô∏è  Security scan was skipped (build may have failed)"
          exit 0
        fi
        
        if [ -f trivy-results.sarif ]; then
          echo "‚úÖ Security scan completed and results available"
          if [ "${{ steps.trivy-scan.outcome }}" == "success" ]; then
            echo "‚úÖ SARIF file uploaded successfully"
          else
            echo "‚ö†Ô∏è  Security scan found issues but results are available"
          fi
        else
          echo "‚ö†Ô∏è  Security scan did not produce SARIF file"
          if [ "${{ steps.trivy-scan.outcome }}" != "success" ]; then
            echo "‚ùå Trivy scan failed - check logs above for details"
            echo "This may happen if the image doesn't exist or Trivy encountered an error"
          fi
        fi

  # =============================================================================
  # PHASE 2: STAGING DEPLOYMENT
  # =============================================================================
  # Purpose: Deploy to staging for testing before production
  # Strategy: Canary or blue-green based on configuration
  # Safety: Handles missing resources gracefully, continue-on-error enabled
  # Dependencies: build-and-security-scan
  # =============================================================================
  
  deploy-staging:
    name: üß™ Deploy to Staging
    runs-on: ubuntu-latest
    needs: [build-and-security-scan]
    if: always() && !cancelled() && needs.build-and-security-scan.result != 'failure'
    environment: staging
    timeout-minutes: 20
    # Add retry strategy for transient failures
    strategy:
      fail-fast: false
      max-parallel: 1
    # Minimal permissions: only read contents (no write access needed)
    permissions:
      contents: read
    continue-on-error: true  # Don't fail entire workflow if staging deployment fails
    
    # Security: Sanitize and validate inputs before use
    env:
      SANITIZED_IMAGE_NAME: ${{ github.event.inputs.image_name || 'amas-orchestrator' }}
      SANITIZED_REGISTRY: ${{ github.event.inputs.docker_registry || 'ghcr.io' }}
    
    steps:
    # ========================================================================
    # STEP 1: Checkout code
    # ========================================================================
    - name: üì• Checkout code
      uses: actions/checkout@v4
    
    # ========================================================================
    # STEP 2: Install kubectl for Kubernetes operations
    # ========================================================================
    - name: üîß Setup kubectl
      uses: azure/setup-kubectl@v3
    
    # ========================================================================
    # STEP 3: Install Argo Rollouts CLI for canary deployments
    # ========================================================================
    - name: üîß Setup Argo Rollouts CLI
      run: |
        curl -LO https://github.com/argoproj/argo-rollouts/releases/latest/download/kubectl-argo-rollouts-linux-amd64
        chmod +x kubectl-argo-rollouts-linux-amd64
        sudo mv kubectl-argo-rollouts-linux-amd64 /usr/local/bin/kubectl-argo-rollouts
    
    - name: üîë Configure Kubernetes
      run: |
        if [ -z "${{ secrets.KUBECONFIG_STAGING }}" ]; then
          echo "‚ö†Ô∏è  KUBECONFIG_STAGING secret not set, skipping staging deployment"
          echo "This is expected if staging cluster is not configured yet"
          exit 0
        fi
        
        echo "${{ secrets.KUBECONFIG_STAGING }}" | base64 -d > $HOME/.kube/config || {
          echo "‚ùå Failed to decode KUBECONFIG_STAGING"
          exit 1
        }
        
        # Verify kubectl works
        kubectl version --client || {
          echo "‚ùå kubectl not working"
          exit 1
        }
        
        # Create namespace if it doesn't exist
        kubectl create namespace amas-staging --dry-run=client -o yaml | kubectl apply -f - || true
        kubectl config set-context --current --namespace=amas-staging
    
    - name: üìã Check Argo Rollouts Installation
      run: |
        if ! kubectl get crd rollouts.argoproj.io &> /dev/null; then
          echo "‚ö†Ô∏è  Argo Rollouts CRD not found in staging cluster"
          echo "‚ö†Ô∏è  Skipping Argo Rollouts deployment, using standard Kubernetes deployment"
          echo "SKIP_ARGO_ROLLOUTS=true" >> $GITHUB_ENV
        else
          echo "‚úÖ Argo Rollouts is installed"
          echo "SKIP_ARGO_ROLLOUTS=false" >> $GITHUB_ENV
        fi
    
    - name: üìã Apply Analysis Templates
      if: env.SKIP_ARGO_ROLLOUTS == 'false'
      run: |
        # Update namespace in analysis templates for staging
        sed 's/namespace: amas-prod/namespace: amas-staging/g' k8s/argo-rollouts/analysis-templates.yaml | \
          kubectl apply -f - || {
          echo "‚ö†Ô∏è  Failed to apply analysis templates (may not exist in staging)"
        }
    
    - name: üöÄ Deploy to staging
      run: |
        echo "üöÄ Deploying to staging..."
        export NAMESPACE=amas-staging
        export ROLLOUT_NAME=amas-orchestrator
        export IMAGE_TAG=${{ github.sha }}
        # Security: Use sanitized values from job env (validated in validate-inputs job)
        export DOCKER_REGISTRY="${SANITIZED_REGISTRY}"
        export IMAGE_NAME="${SANITIZED_IMAGE_NAME}"
        export FULL_IMAGE="${DOCKER_REGISTRY}/${{ github.repository_owner }}/${IMAGE_NAME}:${IMAGE_TAG}"
        
        # Security: Validate image name format before use (defense in depth)
        if [[ ! "$IMAGE_NAME" =~ ^[a-z0-9]([-._/a-z0-9]*[a-z0-9])?$ ]]; then
          echo "‚ùå Invalid image name format detected: $IMAGE_NAME"
          exit 1
        fi
        
        # Security: Only log image name, never credentials
        echo "Deploying image: $FULL_IMAGE"
        
        # Check if rollout exists
        if kubectl get rollout amas-orchestrator -n amas-staging &> /dev/null; then
          echo "‚úÖ Rollout exists, updating image..."
          
          if [ "$SKIP_ARGO_ROLLOUTS" = "false" ] && [ -f scripts/deployment/canary_deploy.sh ]; then
            echo "üöÄ Using canary deployment strategy..."
            chmod +x scripts/deployment/canary_deploy.sh
            export ROLLOUT_NAME=amas-orchestrator
            ./scripts/deployment/canary_deploy.sh || {
              echo "‚ö†Ô∏è  Canary deployment failed, trying basic update..."
              kubectl set image rollout/amas-orchestrator \
                orchestrator="$FULL_IMAGE" \
                -n amas-staging || true
            }
          else
            echo "üöÄ Using standard rollout update..."
            kubectl set image rollout/amas-orchestrator \
              orchestrator="$FULL_IMAGE" \
              -n amas-staging || {
              echo "‚ùå Failed to update rollout"
              exit 1
            }
          fi
        elif kubectl get deployment amas-orchestrator -n amas-staging &> /dev/null; then
          echo "‚úÖ Standard deployment exists, updating image..."
          kubectl set image deployment/amas-orchestrator \
            orchestrator="$FULL_IMAGE" \
            -n amas-staging || {
            echo "‚ùå Failed to update deployment"
            exit 1
          }
        else
          echo "‚ö†Ô∏è  No rollout or deployment found in staging"
          echo "‚ö†Ô∏è  This is expected if staging environment is not fully set up"
          echo "‚ö†Ô∏è  Skipping deployment (this is not a failure)"
          exit 0
        fi
    
    - name: üìä Log Staging Deployment Event
      if: always()
      run: |
        echo "üìä Logging staging deployment event for audit trail..."
        echo "::notice::Deployment Event: environment=staging, commit=${{ github.sha }}, actor=${{ github.actor }}"
    
    - name: üß™ Run staging smoke tests
      run: |
        echo "üß™ Running staging smoke tests..."
        sleep 30  # Wait for deployment to stabilize
        
        # Check rollout status
        if kubectl get rollout amas-orchestrator -n amas-staging &> /dev/null; then
          echo "üìä Checking rollout status..."
          kubectl rollout status rollout/amas-orchestrator -n amas-staging --timeout=5m || {
            echo "‚ö†Ô∏è  Rollout status check completed with warnings"
            # Don't fail the job, just warn
          }
        elif kubectl get deployment amas-orchestrator -n amas-staging &> /dev/null; then
          echo "üìä Checking deployment status..."
          kubectl rollout status deployment/amas-orchestrator -n amas-staging --timeout=5m || {
            echo "‚ö†Ô∏è  Deployment status check completed with warnings"
          }
        else
          echo "‚ö†Ô∏è  No deployment found, skipping status check"
        fi
        
        echo "‚úÖ Staging deployment check completed"

  # =============================================================================
  # PHASE 3: PRODUCTION CANARY DEPLOYMENT
  # =============================================================================
  # Purpose: Production canary deployment (10%‚Üí25%‚Üí50%‚Üí75%‚Üí100%, ~8-9min)
  # Security: Requires production environment approval (GitHub Settings)
  #          Only on main branch pushes or manual dispatch with production env
  # Dependencies: build-and-security-scan, deploy-staging
  # Rollback: Auto-rollback on SLO violations (<95% success, >3s latency, etc.)
  # =============================================================================
  
  deploy-production-canary:
    name: üåü Production Canary Deployment
    runs-on: ubuntu-latest
    needs: [build-and-security-scan, deploy-staging]
    # Only run canary deployment if:
    # - PR merged to main (pull_request.closed with merged=true), OR
    # - Manual dispatch with canary strategy selected AND production environment
    # Security: Production environment requires approval (configured in GitHub Settings)
    if: |
      needs.build-and-security-scan.result == 'success' && (
        (github.event_name == 'pull_request' && 
         github.event.action == 'closed' && 
         github.event.pull_request.merged == true &&
         github.base_ref == 'main') ||
        (github.event_name == 'workflow_dispatch' && 
         github.event.inputs.deployment_strategy == 'canary' &&
         github.event.inputs.environment == 'production')
      )
    environment: 
      name: production
      url: https://amas.example.com
      # Production environment requires approval (configure in GitHub Settings)
      # Configuration: Settings > Environments > production
      # Required settings:
      #   - Required reviewers: [devops-team, security-team] (or specific users)
      #   - Wait timer: 0 (no delay, but requires approval)
      #   - Deployment branches: main (restrict to main branch only)
      # This ensures manual production deployments need explicit approval
    timeout-minutes: 30
    permissions:
      contents: read
    
    steps:
    - name: üì• Checkout code
      uses: actions/checkout@v4
    
    - name: üîß Setup kubectl
      uses: azure/setup-kubectl@v3
    
    - name: üîß Setup Argo Rollouts CLI
      run: |
        curl -LO https://github.com/argoproj/argo-rollouts/releases/latest/download/kubectl-argo-rollouts-linux-amd64
        chmod +x kubectl-argo-rollouts-linux-amd64
        sudo mv kubectl-argo-rollouts-linux-amd64 /usr/local/bin/kubectl-argo-rollouts
    
    - name: üîë Configure Kubernetes
      run: |
        echo "${{ secrets.KUBECONFIG_PRODUCTION }}" | base64 -d > $HOME/.kube/config
        kubectl config set-context --current --namespace=amas-prod
    
    - name: üìã Apply Analysis Templates
      run: |
        # Check if analysis templates file exists
        if [ ! -f k8s/argo-rollouts/analysis-templates.yaml ]; then
          echo "‚ùå Analysis templates file not found"
          exit 1
        fi
        
        # Apply analysis templates with error handling
        if ! kubectl apply -f k8s/argo-rollouts/analysis-templates.yaml; then
          echo "‚ùå Failed to apply analysis templates"
          exit 1
        fi
        
        echo "‚úÖ Analysis templates applied successfully"
    
    - name: üìã Apply Rollout Configuration
      run: |
        # Check if rollout configuration file exists
        if [ ! -f k8s/argo-rollouts/rollout.yaml ]; then
          echo "‚ùå Rollout configuration file not found"
          exit 1
        fi
        
        # Apply rollout configuration with error handling
        if ! kubectl apply -f k8s/argo-rollouts/rollout.yaml; then
          echo "‚ùå Failed to apply rollout configuration"
          exit 1
        fi
        
        echo "‚úÖ Rollout configuration applied successfully"
    
    - name: üöÄ Execute Canary Deployment
      run: |
        echo "üöÄ Starting canary deployment to production..."
        export NAMESPACE=amas-prod
        export ROLLOUT_NAME=amas-orchestrator
        export IMAGE_TAG=${{ github.sha }}
        export DOCKER_REGISTRY=${{ env.DOCKER_REGISTRY }}
        export IMAGE_NAME=${{ env.IMAGE_NAME }}
        
        # Error handling: Check if deployment script exists
        if [ ! -f scripts/deployment/canary_deploy.sh ]; then
          echo "‚ùå Canary deployment script not found"
          exit 1
        fi
        
        chmod +x scripts/deployment/canary_deploy.sh
        
        # Execute deployment with retry logic for transient failures
        MAX_RETRIES=3
        RETRY=0
        while [ $RETRY -lt $MAX_RETRIES ]; do
          if ./scripts/deployment/canary_deploy.sh; then
            echo "‚úÖ Canary deployment initiated successfully"
            exit 0
          fi
          
          RETRY=$((RETRY + 1))
          if [ $RETRY -lt $MAX_RETRIES ]; then
            echo "‚ö†Ô∏è  Deployment attempt $RETRY failed, retrying in 10 seconds..."
            sleep 10
          else
            echo "‚ùå Canary deployment failed after $MAX_RETRIES attempts"
            exit 1
          fi
        done
    
    - name: üìä Monitor Deployment
      run: |
        echo "üìä Monitoring deployment progress..."
        MAX_ITERATIONS=30
        ITERATION=0
        
        while [ $ITERATION -lt $MAX_ITERATIONS ]; do
          ITERATION=$((ITERATION + 1))
          
          # Get rollout status with error handling
          status=$(
            kubectl get rollout amas-orchestrator \
              -n amas-prod \
              -o jsonpath='{.status.phase}' 2>/dev/null || echo "Unknown"
          )
          
          echo "[$ITERATION/$MAX_ITERATIONS] Deployment status: $status"
          
          # Check for failure states
          if [ "$status" = "Degraded" ] || [ "$status" = "Failed" ]; then
            echo "‚ùå Deployment failed, triggering rollback..."
            echo "Status: $status"
            exit 1
          fi
          
          # Check for success state
          if [ "$status" = "Healthy" ]; then
            echo "‚úÖ Deployment completed successfully"
            exit 0
          fi
          
          # Wait before next check
          sleep 20
        done
        
        # Timeout reached
        echo "‚ö†Ô∏è  Deployment monitoring timeout reached"
        echo "Final status: $status"
        exit 1
    
    - name: üìä Log Deployment Event
      if: always()
      run: |
        echo "üìä Logging deployment event for audit trail..."
        # Log deployment event (can be extended to send to external audit system)
        echo "::notice::Deployment Event: environment=production, strategy=canary, commit=${{ github.sha }}, actor=${{ github.actor }}"
        
        # TODO: Add external audit logging integration
        # Example:
        # curl -X POST "${{ secrets.AUDIT_WEBHOOK }}" \
        #   -H "Content-Type: application/json" \
        #   -d "{
        #     \"event\": \"deployment_start\",
        #     \"repo\": \"${{ github.repository }}\",
        #     \"sha\": \"${{ github.sha }}\",
        #     \"actor\": \"${{ github.actor }}\",
        #     \"environment\": \"production\",
        #     \"strategy\": \"canary\"
        #   }"
    
    - name: üß™ Production Smoke Tests
      run: |
        echo "üß™ Running production smoke tests..."
        # Add production smoke tests here
        kubectl get rollout amas-orchestrator -n amas-prod -o wide

  # =============================================================================
  # PHASE 3B: PRODUCTION BLUE-GREEN DEPLOYMENT
  # =============================================================================
  # Purpose: Emergency deployment with instant traffic switching
  # Security: Requires production environment approval (GitHub Settings)
  #          Only on manual dispatch with blue-green + production
  # Dependencies: build-and-security-scan, deploy-staging
  # Use Case: Emergency deployments, hotfixes, instant switch needed
  # =============================================================================
  
  deploy-production-blue-green:
    name: üîµ Production Blue-Green Deployment
    runs-on: ubuntu-latest
    needs: [build-and-security-scan, deploy-staging]
    # Only run blue-green deployment if manually selected for production
    # Security: Production environment requires approval (configured in GitHub Settings)
    if: |
      needs.build-and-security-scan.result == 'success' && (
        github.event_name == 'workflow_dispatch' && 
        github.event.inputs.deployment_strategy == 'blue-green' &&
        github.event.inputs.environment == 'production'
      )
    environment: 
      name: production
      url: https://amas.example.com
      # Production environment requires approval (configure in GitHub Settings)
      # Add required reviewers in: Settings > Environments > production
      # Example configuration:
      #   required-reviewers: [devops-team, security-team]
    timeout-minutes: 20  # Blue-green is faster (instant switch)
    permissions:
      contents: read
    
    steps:
    - name: üì• Checkout code
      uses: actions/checkout@v4
    
    - name: üîß Setup kubectl
      uses: azure/setup-kubectl@v3
    
    - name: üîë Configure Kubernetes
      run: |
        echo "${{ secrets.KUBECONFIG_PRODUCTION }}" | base64 -d > $HOME/.kube/config
        kubectl config set-context --current --namespace=amas-prod
    
    - name: üöÄ Execute Blue-Green Deployment
      run: |
        echo "üöÄ Starting blue-green deployment to production..."
        export NAMESPACE=amas-prod
        export SERVICE_NAME=amas-orchestrator
        export IMAGE_TAG=${{ github.sha }}
        export DOCKER_REGISTRY=${{ env.DOCKER_REGISTRY }}
        export IMAGE_NAME=${{ env.IMAGE_NAME }}
        
        if [ ! -f scripts/deployment/blue_green_deploy.sh ]; then
          echo "‚ùå Blue-green deployment script not found"
          exit 1
        fi
        
        chmod +x scripts/deployment/blue_green_deploy.sh
        
        # Execute deployment with retry logic for transient failures
        MAX_RETRIES=3
        RETRY=0
        while [ $RETRY -lt $MAX_RETRIES ]; do
          if ./scripts/deployment/blue_green_deploy.sh deploy; then
            echo "‚úÖ Blue-green deployment initiated successfully"
            exit 0
          fi
          
          RETRY=$((RETRY + 1))
          if [ $RETRY -lt $MAX_RETRIES ]; then
            echo "‚ö†Ô∏è  Deployment attempt $RETRY failed, retrying in 10 seconds..."
            sleep 10
          else
            echo "‚ùå Blue-green deployment failed after $MAX_RETRIES attempts"
            exit 1
          fi
        done
    
    - name: üìä Log Deployment Event
      if: always()
      run: |
        echo "üìä Logging deployment event for audit trail..."
        echo "::notice::Deployment Event: environment=production, strategy=blue-green, commit=${{ github.sha }}, actor=${{ github.actor }}"
    
    - name: üß™ Production Smoke Tests
      run: |
        echo "üß™ Running production smoke tests..."
        kubectl get deployments -n amas-prod -l "app=amas-orchestrator" -o wide

  # =============================================================================
  # PHASE 4: EMERGENCY ROLLBACK
  # =============================================================================
  # Purpose: Auto-rollback production deployment on failure (<2min)
  # Trigger: Production deployment failure
  # Dependencies: deploy-production-canary or deploy-production-blue-green (on failure)
  # Security: Requires production environment access
  # =============================================================================
  
  emergency-rollback:
    name: üîÑ Emergency Rollback
    runs-on: ubuntu-latest
    # Trigger rollback if either deployment strategy fails
    if: |
      failure() && (
        (needs.deploy-production-canary.result == 'failure') ||
        (needs.deploy-production-blue-green.result == 'failure')
      )
    environment: production
    timeout-minutes: 10
    permissions:
      contents: read
    
    steps:
    - name: üì• Checkout code
      uses: actions/checkout@v4
    
    - name: üîß Setup kubectl
      uses: azure/setup-kubectl@v3
    
    - name: üîë Configure Kubernetes
      run: |
        echo "${{ secrets.KUBECONFIG_PRODUCTION }}" | base64 -d > $HOME/.kube/config
        kubectl config set-context --current --namespace=amas-prod
    
    - name: üîÑ Execute Rollback
      run: |
        echo "üîÑ Executing emergency rollback..."
        
        # Check if rollout exists before attempting rollback
        if ! kubectl get rollout amas-orchestrator -n amas-prod &> /dev/null; then
          echo "‚ö†Ô∏è  Rollout not found, cannot rollback"
          exit 1
        fi
        
        # Get current revision for logging
        CURRENT_REV=$(kubectl get rollout amas-orchestrator \
          -n amas-prod \
          -o jsonpath='{.status.currentRevision}' 2>/dev/null || echo "unknown")
        echo "Current revision: $CURRENT_REV"
        
        # Execute rollback with error handling
        if ! kubectl rollout undo rollout/amas-orchestrator -n amas-prod; then
          echo "‚ùå Rollback command failed"
          exit 1
        fi
        
        # Wait for rollback to complete
        if ! kubectl rollout status rollout/amas-orchestrator \
          -n amas-prod \
          --timeout=5m; then
          echo "‚ùå Rollback did not complete within timeout"
          exit 1
        fi
        
        # Verify rollback success
        NEW_REV=$(kubectl get rollout amas-orchestrator \
          -n amas-prod \
          -o jsonpath='{.status.currentRevision}' 2>/dev/null || echo "unknown")
        echo "‚úÖ Rollback completed successfully"
        echo "New revision: $NEW_REV"
    
    - name: üì¢ Notify Rollback
      if: always()
      run: |
        echo "üì¢ Emergency rollback completed"
        echo "üö® Incident response team should be notified here"
        # TODO: Add notification integration (Slack, email, PagerDuty, etc.)
        # Example:
        # - name: Notify Slack
        #   uses: slackapi/slack-github-action@v1
        #   with:
        #     webhook-url: ${{ secrets.SLACK_WEBHOOK }}
        #     payload: |
        #       {
        #         "text": "üö® Emergency rollback executed for AMAS deployment"
        #       }

  # =============================================================================
  # PHASE 5: FAILURE NOTIFICATIONS
  # =============================================================================
  # Purpose: Notify on workflow failures for observability
  # Trigger: Any workflow failure (not cancelled)
  # Dependencies: All deployment jobs (monitors status)
  # Output: GitHub Actions summary with failure details
  # TODO: External notifications (Slack, email, PagerDuty)
  # =============================================================================
  
  notify-failure:
    name: üì¢ Notify on Failure
    runs-on: ubuntu-latest
    needs: [build-and-security-scan, deploy-staging, deploy-production-canary, deploy-production-blue-green]
    if: failure() && !cancelled()
    timeout-minutes: 5
    permissions:
      contents: read
    
    steps:
    - name: üì¢ Generate failure report
      run: |
        echo "## üö® Workflow Failure Report" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "**Workflow:** Progressive Delivery Pipeline" >> $GITHUB_STEP_SUMMARY
        echo "**Commit:** ${{ github.sha }}" >> $GITHUB_STEP_SUMMARY
        echo "**Branch:** ${{ github.ref_name }}" >> $GITHUB_STEP_SUMMARY
        echo "**Triggered by:** ${{ github.actor }}" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "### Failed Jobs:" >> $GITHUB_STEP_SUMMARY
        echo "- Build & Security Scan: ${{ needs.build-and-security-scan.result }}" >> $GITHUB_STEP_SUMMARY
        echo "- Deploy Staging: ${{ needs.deploy-staging.result }}" >> $GITHUB_STEP_SUMMARY
        echo "- Deploy Production Canary: ${{ needs.deploy-production-canary.result }}" >> $GITHUB_STEP_SUMMARY
        echo "- Deploy Production Blue-Green: ${{ needs.deploy-production-blue-green.result }}" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "### Next Steps:" >> $GITHUB_STEP_SUMMARY
        echo "1. Review workflow logs for detailed error information" >> $GITHUB_STEP_SUMMARY
        echo "2. Check if emergency rollback was triggered" >> $GITHUB_STEP_SUMMARY
        echo "3. Verify deployment status in Kubernetes cluster" >> $GITHUB_STEP_SUMMARY
        
        # TODO: Add external notification integration
        # Example Slack notification:
        # - name: Notify Slack
        #   if: always()
        #   uses: slackapi/slack-github-action@v1
        #   with:
        #     webhook-url: ${{ secrets.SLACK_WEBHOOK }}
        #     payload: |
        #       {
        #         "text": "üö® Progressive Delivery Pipeline failed",
        #         "blocks": [
        #           {
        #             "type": "section",
        #             "text": {
        #               "type": "mrkdwn",
        #               "text": "*Workflow:* Progressive Delivery Pipeline\n*Status:* Failed\n*Commit:* ${{ github.sha }}"
        #             }
        #           }
        #         ]
        #       }
        
        echo "‚úÖ Failure notification prepared"
