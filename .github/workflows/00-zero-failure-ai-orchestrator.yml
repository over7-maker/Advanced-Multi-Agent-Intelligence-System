name: Zero-Failure AI Orchestrator

# Reusable workflow for AI tasks with 16-provider fallback chain
# This workflow ensures zero failures by trying all available providers sequentially

on:
  workflow_call:
    inputs:
      task_type:
        description: 'Type of AI task (code_review, pr_analysis, security_scan, etc.)'
        required: true
        type: string
      system_message:
        description: 'System message for AI context'
        required: true
        type: string
      user_prompt:
        description: 'User prompt/query for AI'
        required: true
        type: string
      max_tokens:
        description: 'Maximum tokens for AI response'
        required: false
        type: number
        default: 2000
      temperature:
        description: 'Temperature for AI generation'
        required: false
        type: number
        default: 0.7
      use_cache:
        description: 'Enable response caching'
        required: false
        type: boolean
        default: true
    outputs:
      success:
        description: 'Whether the AI task succeeded'
        value: ${{ jobs.orchestrate.outputs.success }}
      provider:
        description: 'Provider that succeeded (or "none" if all failed)'
        value: ${{ jobs.orchestrate.outputs.provider }}
      response:
        description: 'AI response text'
        value: ${{ jobs.orchestrate.outputs.response }}
      duration_ms:
        description: 'Execution duration in milliseconds'
        value: ${{ jobs.orchestrate.outputs.duration_ms }}
      fallback_count:
        description: 'Number of providers tried before success'
        value: ${{ jobs.orchestrate.outputs.fallback_count }}
      cached:
        description: 'Whether response was from cache'
        value: ${{ jobs.orchestrate.outputs.cached }}
    secrets:
      DEEPSEEK_API_KEY:
        required: false
      GLM_API_KEY:
        required: false
      GROK_API_KEY:
        required: false
      KIMI_API_KEY:
        required: false
      QWEN_API_KEY:
        required: false
      GPTOSS_API_KEY:
        required: false
      NVIDIA_API_KEY:
        required: false
      CODESTRAL_API_KEY:
        required: false
      CHUTES_API_KEY:
        required: false
      CEREBRAS_API_KEY:
        required: false
      GEMINIAI_API_KEY:
        required: false
      GEMINI2_API_KEY:
        required: false
      GROQAI_API_KEY:
        required: false
      GROQ2_API_KEY:
        required: false
      COHERE_API_KEY:
        required: false

env:
  PYTHON_VERSION: '3.11'

jobs:
  orchestrate:
    runs-on: ubuntu-latest
    timeout-minutes: 10
    
    outputs:
      success: ${{ steps.execute.outputs.success }}
      provider: ${{ steps.execute.outputs.provider }}
      response: ${{ steps.execute.outputs.response }}
      duration_ms: ${{ steps.execute.outputs.duration_ms }}
      fallback_count: ${{ steps.execute.outputs.fallback_count }}
      cached: ${{ steps.execute.outputs.cached }}
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
    
    - name: Set up Python
      uses: actions/setup-python@v5
      with:
        python-version: ${{ env.PYTHON_VERSION }}
        cache: 'pip'
    
    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        python -m pip install aiohttp
    
    - name: Execute AI Orchestrator
      id: execute
      env:
        DEEPSEEK_API_KEY: ${{ secrets.DEEPSEEK_API_KEY }}
        GLM_API_KEY: ${{ secrets.GLM_API_KEY }}
        GROK_API_KEY: ${{ secrets.GROK_API_KEY }}
        KIMI_API_KEY: ${{ secrets.KIMI_API_KEY }}
        QWEN_API_KEY: ${{ secrets.QWEN_API_KEY }}
        GPTOSS_API_KEY: ${{ secrets.GPTOSS_API_KEY }}
        NVIDIA_API_KEY: ${{ secrets.NVIDIA_API_KEY }}
        CODESTRAL_API_KEY: ${{ secrets.CODESTRAL_API_KEY }}
        CHUTES_API_KEY: ${{ secrets.CHUTES_API_KEY }}
        CEREBRAS_API_KEY: ${{ secrets.CEREBRAS_API_KEY }}
        GEMINIAI_API_KEY: ${{ secrets.GEMINIAI_API_KEY }}
        GEMINI2_API_KEY: ${{ secrets.GEMINI2_API_KEY }}
        GROQAI_API_KEY: ${{ secrets.GROQAI_API_KEY }}
        GROQ2_API_KEY: ${{ secrets.GROQ2_API_KEY }}
        COHERE_API_KEY: ${{ secrets.COHERE_API_KEY }}
      run: |
        python .github/scripts/ai_orchestrator.py \
          --task-type "${{ inputs.task_type }}" \
          --system-message "${{ inputs.system_message }}" \
          --user-prompt "${{ inputs.user_prompt }}" \
          --max-tokens ${{ inputs.max_tokens }} \
          --temperature ${{ inputs.temperature }} \
          ${{ inputs.use_cache == false && '--no-cache' || '' }} \
          --output orchestrator_result.json
        
        # Extract outputs
        SUCCESS=$(python -c "import json; d=json.load(open('orchestrator_result.json')); print('true' if d.get('success') else 'false')")
        PROVIDER=$(python -c "import json; d=json.load(open('orchestrator_result.json')); print(d.get('provider', 'none'))")
        RESPONSE=$(python -c "import json; d=json.load(open('orchestrator_result.json')); print(d.get('response', '')[:65536])" | head -c 65536)
        DURATION_MS=$(python -c "import json; d=json.load(open('orchestrator_result.json')); print(d.get('duration_ms', 0))")
        FALLBACK_COUNT=$(python -c "import json; d=json.load(open('orchestrator_result.json')); print(d.get('fallback_count', 0))")
        CACHED=$(python -c "import json; d=json.load(open('orchestrator_result.json')); print('true' if d.get('cached') else 'false')")
        
        echo "success=$SUCCESS" >> $GITHUB_OUTPUT
        echo "provider=$PROVIDER" >> $GITHUB_OUTPUT
        echo "response<<EOF" >> $GITHUB_OUTPUT
        echo "$RESPONSE" >> $GITHUB_OUTPUT
        echo "EOF" >> $GITHUB_OUTPUT
        echo "duration_ms=$DURATION_MS" >> $GITHUB_OUTPUT
        echo "fallback_count=$FALLBACK_COUNT" >> $GITHUB_OUTPUT
        echo "cached=$CACHED" >> $GITHUB_OUTPUT
      continue-on-error: true
    
    - name: Upload execution logs
      if: always()
      uses: actions/upload-artifact@v4
      with:
        name: orchestrator-logs
        path: |
          orchestrator_result.json
          .github/data/metrics/*.jsonl
        retention-days: 7
    
    - name: Report result (non-blocking)
      if: always()
      run: |
        if [ "${{ steps.execute.outputs.success }}" != "true" ]; then
          echo "‚ö†Ô∏è AI Orchestrator: All providers failed, but workflow continues (non-blocking)"
          echo "Provider: ${{ steps.execute.outputs.provider }}"
          echo "Fallback count: ${{ steps.execute.outputs.fallback_count }}"
        else
          echo "‚úÖ AI Orchestrator: Success with provider ${{ steps.execute.outputs.provider }}"
          if [ "${{ steps.execute.outputs.cached }}" == "true" ]; then
            echo "üì¶ Response served from cache"
          fi
        fi
