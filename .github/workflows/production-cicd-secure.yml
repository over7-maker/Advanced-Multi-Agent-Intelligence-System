name: ðŸš€ AMAS Secure Production CI/CD Pipeline

# Least-privilege defaults; elevate per job only when needed
permissions:
  contents: read

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]
  release:
    types: [published]
  workflow_dispatch:
    inputs:
      environment:
        description: 'Deployment environment'
        required: true
        default: 'staging'
        type: choice
        options:
          - staging
      skip_tests:
        description: 'Skip non-critical tests (security tests always run)'
        required: false
        default: false
        type: boolean

env:
  PYTHON_VERSION: '3.11.13'
  NODE_VERSION: '20'
  DOCKER_REGISTRY: ghcr.io
  IMAGE_NAME: amas
  REGISTRY_USERNAME: ${{ github.repository_owner }}

jobs:
  security-scan:
    name: ðŸ”’ Security Vulnerability Scan
    runs-on: ubuntu-latest
    timeout-minutes: 20
    concurrency:
      group: security-scan-${{ github.ref }}-${{ github.event.inputs.environment || 'push' }}
      cancel-in-progress: true
    outputs:
      vulnerabilities-found: ${{ steps.scan-results.outputs.vulnerabilities }}
      critical-vulnerabilities: ${{ steps.scan-results.outputs.critical-vulnerabilities }}
      passed: ${{ steps.scan-results.outputs.passed }}
    env:
      REQUIREMENTS_FILE: requirements-security.txt

    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 1
      - uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_VERSION }}
          cache: 'pip'
          cache-dependency-path: ${{ env.REQUIREMENTS_FILE }}
      - name: Install security tools
        env:
          PYTHON_VERSION: ${{ env.PYTHON_VERSION }}
        run: |
          set -euo pipefail
          
          # Upgrade pip before installing packages to ensure latest version
          # This improves dependency resolution speed and security vulnerability fixes
          python -m pip install --upgrade pip
          
          # Validate requirements file exists and is readable
          # Check file existence, non-empty, and basic readability
          if [ ! -f "$REQUIREMENTS_FILE" ]; then
            echo "âŒ Requirements file not found: $REQUIREMENTS_FILE"
            echo "ðŸ’¡ Expected location: repository root ($REQUIREMENTS_FILE)"
            exit 1
          fi
          
          if [ ! -r "$REQUIREMENTS_FILE" ]; then
            echo "âŒ Requirements file is not readable: $REQUIREMENTS_FILE"
            echo "ðŸ’¡ Check file permissions"
            exit 1
          fi
          
          if [ ! -s "$REQUIREMENTS_FILE" ]; then
            echo "âŒ Requirements file is empty: $REQUIREMENTS_FILE"
            echo "ðŸ’¡ File must contain at least one package specification"
            exit 1
          fi
          
          # Attempt installation with hash verification first (most secure method)
          # SECURITY BENEFIT: Hash verification prevents supply chain attacks by ensuring:
          # - Package integrity (detects tampering during download)
          # - Dependency confusion attacks (ensures correct package is installed)
          # - MITM attacks (validates package hasn't been modified in transit)
          # Use subshell to minimize scope of error handling changes
          pip_output=$(pip install --require-hashes -r "$REQUIREMENTS_FILE" 2>&1) || pip_exit_code=$?
          pip_exit_code=${pip_exit_code:-0}
          
          # Check if failure is due to missing hashes (case-insensitive fixed-string match)
          # SECURITY BENEFIT: Fixed-string matching prevents regex injection attacks where
          # malicious pip output could exploit regex metacharacters to bypass detection
          # These patterns are from pip's standard error messages (trusted source)
          hash_error_pattern="hashes are required"
          missing_hash_pattern="missing from some requirements"
          is_hash_error=false
          
          if [ $pip_exit_code -ne 0 ]; then
            # Use fixed-string matching (-F flag) to avoid regex injection risks
            # This ensures only exact matches of pip's known error messages are detected
            if echo "$pip_output" | grep -qiF "$hash_error_pattern" || \
               echo "$pip_output" | grep -qiF "$missing_hash_pattern"; then
              is_hash_error=true
            fi
          fi
          
          if [ "$is_hash_error" = true ]; then
            echo "âš ï¸  SECURITY TRADE-OFF: Hashes not available in $REQUIREMENTS_FILE"
            echo "âš ï¸  Installing without hash verification increases supply chain attack risk"
            echo "âš ï¸  RISKS: Dependency confusion, package tampering, MITM attacks"
            echo "âš ï¸  RECOMMENDATION: Generate hashes using: pip-compile --generate-hashes $REQUIREMENTS_FILE"
            echo "âš ï¸  See SECURITY.md for details on secure dependency management"
            
            # Fallback: Install without hash verification (less secure but functional)
            # SECURITY WARNING: This defeats hash verification - only acceptable for development/staging
            # In production, this should fail the build to enforce security requirements
            pip_fallback_output=$(pip install -r "$REQUIREMENTS_FILE" 2>&1) || pip_fallback_exit=$?
            pip_fallback_exit=${pip_fallback_exit:-0}
            
            if [ $pip_fallback_exit -ne 0 ]; then
              echo "âŒ Fallback pip install failed with exit code $pip_fallback_exit"
              echo "ðŸ“‹ Error details:"
              echo "$pip_fallback_output"
              echo "ðŸ’¡ Check $REQUIREMENTS_FILE for:"
              echo "   - Syntax errors (invalid package specifications)"
              echo "   - Missing dependencies (unavailable packages)"
              echo "   - Network connectivity issues"
              exit $pip_fallback_exit
            else
              echo "âš ï¸  Installed without hash verification (security risk accepted)"
            fi
          elif [ $pip_exit_code -ne 0 ]; then
            # Other installation errors (network, syntax, invalid hashes, etc.)
            echo "âŒ pip install failed with exit code $pip_exit_code"
            echo "ðŸ“‹ Error output:"
            echo "$pip_output"
            echo "ðŸ’¡ Possible causes:"
            echo "   - Network connectivity issues"
            echo "   - Invalid or outdated package hashes in $REQUIREMENTS_FILE"
            echo "   - Syntax errors in $REQUIREMENTS_FILE"
            echo "   - Package index unavailable"
            exit $pip_exit_code
          else
            echo "âœ… Installed with hash verification (secure - all packages verified)"
          fi
          
          # Verify security tools are installed and accessible
          echo "ðŸ” Verifying security tool installations..."
          command -v safety >/dev/null 2>&1 || { echo "âŒ safety not found"; exit 1; }
          command -v bandit >/dev/null 2>&1 || { echo "âŒ bandit not found"; exit 1; }
          echo "âœ… Security tools verified"
      - name: Safety
        continue-on-error: true
        timeout-minutes: 5
        run: |
          set +e
          set -o pipefail
          
          # Run Safety vulnerability scanner with timeout (5 minutes max)
          # Safety checks Python dependencies against known vulnerability database
          timeout 300s safety check --json > safety-report.json 2>&1 || true
          original_exit_code=${PIPESTATUS[0]}
          exit_code=$original_exit_code
          set -euo pipefail
          
          # Validate JSON output format
          if ! jq empty safety-report.json 2>jq-error.log; then
            error_msg=$(cat jq-error.log 2>/dev/null || echo 'invalid JSON format')
            echo "âš ï¸  JSON validation failed: $error_msg"
            echo "âš ï¸  Creating empty Safety report"
            echo "[]" > safety-report.json
            # Preserve original exit code, but note JSON issue
            if [ $original_exit_code -eq 0 ]; then
              exit_code=64
            fi
          fi
          
          # Interpret exit codes:
          # 0 = No vulnerabilities found
          # 1 = Vulnerabilities found
          # 64+ = Tool error (database/API/network issue)
          if [ $exit_code -eq 0 ]; then
            echo "âœ… Safety scan completed, no vulnerabilities found"
          elif [ $exit_code -eq 1 ]; then
            echo "âš ï¸  Safety found vulnerabilities (see safety-report.json)"
          else
            echo "âš ï¸  Safety check failed with exit code $exit_code (database/API issue - continuing)"
            if [ $exit_code -ne 64 ]; then
              echo "[]" > safety-report.json
            fi
          fi
          
          # Explicitly exit with captured exit code for proper workflow status
          exit $exit_code
      - name: Bandit
        continue-on-error: true
        timeout-minutes: 10
        env:
          SCAN_TARGET: src
        run: |
          set +e
          set -o pipefail
          
          # Check if source directory exists
          if [ -d "$SCAN_TARGET" ]; then
            # Run Bandit static security analysis with timeout (10 minutes max)
            # Bandit scans Python code for common security issues
            timeout 600s bandit -r "$SCAN_TARGET" -f json -o bandit-report.json 2>&1 || true
            original_exit_code=${PIPESTATUS[0]}
            exit_code=$original_exit_code
            set -euo pipefail
            
            # Validate JSON output format
            if ! jq empty bandit-report.json 2>jq-error.log; then
              error_msg=$(cat jq-error.log 2>/dev/null || echo 'invalid JSON format')
              echo "âš ï¸  JSON validation failed: $error_msg"
              echo "âš ï¸  Creating empty Bandit report"
              echo '{"results":[],"generated_at":"'"$(date -Iseconds)"'","metadata":{"bandit_version":"unknown"}}' > bandit-report.json
              # Preserve original exit code, but note JSON issue
              if [ $original_exit_code -eq 0 ]; then
                exit_code=2
              fi
            fi
            
            # Interpret exit codes:
            # 0 = No issues found
            # 1 = Security issues found
            # 2+ = Execution error
            if [ $exit_code -eq 0 ]; then
              echo "âœ… Bandit scan completed, no security issues found"
            elif [ $exit_code -eq 1 ]; then
              echo "âš ï¸  Bandit found security issues (see bandit-report.json)"
            else
              echo "âš ï¸  Bandit check failed with exit code $exit_code (execution error - continuing)"
              if [ $exit_code -ne 2 ]; then
                echo '{"results":[],"generated_at":"'"$(date -Iseconds)"'","metadata":{"bandit_version":"unknown"}}' > bandit-report.json
              fi
            fi
          else
            echo "â„¹ï¸  Directory '$SCAN_TARGET' not found â€” skipping Bandit scan"
            echo '{"results":[],"generated_at":"'"$(date -Iseconds)"'","metadata":{"bandit_version":"unknown"}}' > bandit-report.json
            exit_code=0
          fi
          
          # Explicitly exit with captured exit code for proper workflow status
          exit $exit_code
      - name: Semgrep Scan
        uses: returntocorp/semgrep-action@v1
        continue-on-error: true
        with:
          config: >-
            p/security-audit
            p/secrets
            p/owasp-top-ten
      - name: Generate SARIF report
        run: |
          # Generate SARIF report using installed semgrep
          if command -v semgrep >/dev/null 2>&1 || python -m semgrep --version >/dev/null 2>&1; then
            python -m semgrep scan \
              --sarif \
              --output=semgrep.sarif \
              --config=p/security-audit \
              --config=p/secrets \
              --config=p/owasp-top-ten \
              --timeout=300 || true
          else
            echo "âš ï¸  Semgrep not available, creating empty SARIF"
            echo '{"version": "2.1.0", "$schema": "https://raw.githubusercontent.com/oasis-tcs/sarif-spec/master/Schemata/sarif-schema-2.1.0.json", "runs": [{"results": []}]}' > semgrep.sarif
          fi
        continue-on-error: true
      - name: Semgrep CI
        run: |
          # Semgrep CI requires authentication, skip if not available
          if [ -n "${{ secrets.SEMGREP_APP_TOKEN }}" ]; then
            python -m semgrep ci --sarif --output=semgrep-ci.sarif || true
          else
            echo "âš ï¸  SEMGREP_APP_TOKEN not set, skipping Semgrep CI scan"
            echo '{"version": "2.1.0", "$schema": "https://raw.githubusercontent.com/oasis-tcs/sarif-spec/master/Schemata/sarif-schema-2.1.0.json", "runs": [{"results": []}]}' > semgrep-ci.sarif || true
          fi
        continue-on-error: true
      - name: Upload SARIF
        uses: github/codeql-action/upload-sarif@v3
        if: always() && hashFiles('semgrep.sarif') != ''
        with:
          sarif_file: semgrep.sarif
      - name: Upload security artifacts
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: security-reports-${{ github.sha }}
          path: |
            safety-report.json
            bandit-report.json
            semgrep.sarif
            semgrep-ci.sarif
          retention-days: 30
      - name: Evaluate
        id: scan-results
        run: |
          # Initialize vulnerability counters
          vuln=0
          crit=0
          
          # Ensure report files exist (create empty if missing)
          [ ! -f safety-report.json ] && echo "[]" > safety-report.json || true
          [ ! -f bandit-report.json ] && echo '{"results":[]}' > bandit-report.json || true
          
          # Count vulnerabilities from Safety scan
          # Safety reports vulnerabilities as a JSON array
          if [ -s safety-report.json ]; then
            safety_count=$(jq 'if type=="array" then length else 0 end' safety-report.json 2>/dev/null || echo 0)
            vuln=$((vuln + safety_count))
            echo "ðŸ“Š Safety: Found $safety_count vulnerabilities"
          fi
          
          # Count vulnerabilities from Bandit scan
          # Bandit reports issues in .results array with severity levels
          if [ -s bandit-report.json ]; then
            bandit_count=$(jq '.results|length' bandit-report.json 2>/dev/null || echo 0)
            vuln=$((vuln + bandit_count))
            
            # Count critical/high severity issues (these will fail the build)
            crit=$(jq '[.results[] | select(.issue_severity=="HIGH" or .issue_severity=="CRITICAL")] | length' bandit-report.json 2>/dev/null || echo 0)
            echo "ðŸ“Š Bandit: Found $bandit_count issues ($crit critical/high severity)"
          fi
          
          # Set workflow outputs for downstream jobs
          echo "vulnerabilities=$vuln" >> $GITHUB_OUTPUT
          echo "critical-vulnerabilities=$crit" >> $GITHUB_OUTPUT
          echo "passed=$([ "$crit" -eq 0 ] && echo true || echo false)" >> $GITHUB_OUTPUT
          echo "ðŸ“Š Security Scan Summary: $vuln total vulnerabilities, $crit critical"
          
          # Fail the job if critical vulnerabilities are found (security gate)
          if [ "$crit" -gt 0 ]; then
            echo "âŒ Security scan FAILED: Found $crit critical vulnerabilities"
            echo "ðŸ”’ Security gate: Critical vulnerabilities must be resolved before merge"
            exit 1
          elif [ "$vuln" -gt 10 ]; then
            echo "âš ï¸  Security scan WARNING: Found $vuln total vulnerabilities (threshold: 10)"
            echo "âš ï¸  Consider reviewing and fixing vulnerabilities before merging"
          else
            echo "âœ… Security scan PASSED: $vuln total vulnerabilities, $crit critical"
          fi
          
          # Additional enforcement: Check Safety for critical/high severity vulnerabilities
          if [ -s safety-report.json ]; then
            safety_critical=$(jq '[.[] | select(.severity == "CRITICAL" or .severity == "HIGH")] | length' safety-report.json 2>/dev/null || echo 0)
            if [ "$safety_critical" -gt 0 ]; then
              echo "âŒ Safety found $safety_critical critical/high severity vulnerabilities"
              echo "ðŸ”’ Security gate: Critical dependency vulnerabilities must be resolved"
              exit 1
            fi
          fi
          
          # Create GitHub job summary for visibility in Actions UI
          echo "## ðŸ”’ Security Scan Results" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Tool | Status | Vulnerabilities | Critical |" >> $GITHUB_STEP_SUMMARY
          echo "|------|--------|-----------------|----------|" >> $GITHUB_STEP_SUMMARY
          safety_count=$(jq 'length' safety-report.json 2>/dev/null || echo 0)
          bandit_count=$(jq '.results|length' bandit-report.json 2>/dev/null || echo 0)
          echo "| Safety | $([ "$safety_count" -eq 0 ] && echo "âœ… Pass" || echo "âš ï¸ Issues") | $safety_count | - |" >> $GITHUB_STEP_SUMMARY
          echo "| Bandit | $([ "$bandit_count" -eq 0 ] && echo "âœ… Pass" || echo "âš ï¸ Issues") | $bandit_count | $crit |" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Total:** $vuln vulnerabilities, $crit critical" >> $GITHUB_STEP_SUMMARY
