name: ðŸš€ AMAS Secure Production CI/CD Pipeline

# Least-privilege defaults; elevate per job only when needed
permissions:
  contents: read

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]
  release:
    types: [published]
  workflow_dispatch:
    inputs:
      environment:
        description: 'Deployment environment'
        required: true
        default: 'staging'
        type: choice
        options:
          - staging
      skip_tests:
        description: 'Skip non-critical tests (security tests always run)'
        required: false
        default: false
        type: boolean

env:
  PYTHON_VERSION: '3.11.13'
  NODE_VERSION: '20'
  DOCKER_REGISTRY: ghcr.io
  IMAGE_NAME: amas
  REGISTRY_USERNAME: ${{ github.repository_owner }}

jobs:
  security-scan:
    name: ðŸ”’ Security Vulnerability Scan
    runs-on: ubuntu-latest
    timeout-minutes: 20
    concurrency:
      group: security-scan-${{ github.ref }}-${{ github.event.inputs.environment || 'push' }}
      cancel-in-progress: true
    outputs:
      vulnerabilities-found: ${{ steps.scan-results.outputs.vulnerabilities }}
      critical-vulnerabilities: ${{ steps.scan-results.outputs.critical-vulnerabilities }}
      passed: ${{ steps.scan-results.outputs.passed }}

    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 1
      - uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_VERSION }}
          cache: 'pip'
          cache-dependency-path: requirements-security.txt
      - name: Install security tools
        shell: bash
        run: |
          set -euo pipefail
          # Check if requirements file exists
          if [ ! -f requirements-security.txt ]; then
            echo "âŒ requirements-security.txt not found"
            exit 1
          fi
          # Try with hashes first, fallback if hashes not available
          # Note: This fallback is a known security trade-off until requirements-security.txt includes hashes
          set +e
          pip_output=$(pip install --require-hashes -r requirements-security.txt 2>&1)
          pip_exit_code=$?
          set -euo pipefail
          if [ $pip_exit_code -ne 0 ] && echo "$pip_output" | grep -qE "(Hashes are required|missing from some requirements)"; then
            echo "âš ï¸  Hashes not available in requirements-security.txt, installing without hash verification"
            echo "âš ï¸  SECURITY NOTE: Consider adding hashes to requirements-security.txt using: pip-compile --generate-hashes"
            pip install -r requirements-security.txt
          elif [ $pip_exit_code -ne 0 ]; then
            echo "âŒ pip install failed with exit code $pip_exit_code"
            echo "$pip_output"
            exit $pip_exit_code
          else
            echo "âœ… Installed with hash verification"
          fi
      - name: Safety
        continue-on-error: true
        timeout-minutes: 5
        run: |
          set +e
          set -o pipefail
          # Run safety with timeout and capture output and exit code properly
          timeout 300s safety check --json > safety-report.json 2>&1
          original_exit_code=$?
          exit_code=$original_exit_code
          set -euo pipefail
          # Validate JSON output
          if ! jq empty safety-report.json 2>jq-error.log; then
            echo "âš ï¸  JSON validation failed: $(cat jq-error.log 2>/dev/null || echo 'invalid JSON')"
            echo "âš ï¸  Creating empty Safety report"
            echo "[]" > safety-report.json
            # Preserve original exit code, but note JSON issue
            if [ $original_exit_code -eq 0 ]; then
              exit_code=64
            fi
          fi
          if [ $exit_code -eq 0 ]; then
            echo "âœ… Safety scan completed, no vulnerabilities"
          elif [ $exit_code -eq 1 ]; then
            echo "âš ï¸  Safety found vulnerabilities (see safety-report.json)"
          else
            echo "âš ï¸  Safety check failed with exit code $exit_code (database/API issue - continuing)"
            if [ $exit_code -ne 64 ]; then
              echo "[]" > safety-report.json
            fi
          fi
          # Explicitly exit with captured exit code
          exit $exit_code
      - name: Bandit
        continue-on-error: true
        timeout-minutes: 10
        env:
          SCAN_TARGET: src
        run: |
          set +e
          set -o pipefail
          if [ -d "$SCAN_TARGET" ]; then
            # Run bandit with timeout and capture exit code properly
            timeout 600s bandit -r "$SCAN_TARGET" -f json -o bandit-report.json 2>&1
            original_exit_code=$?
            exit_code=$original_exit_code
            set -euo pipefail
            # Validate JSON output
            if ! jq empty bandit-report.json 2>jq-error.log; then
              echo "âš ï¸  JSON validation failed: $(cat jq-error.log 2>/dev/null || echo 'invalid JSON')"
              echo "âš ï¸  Creating empty Bandit report"
              echo '{"results":[],"generated_at":"'"$(date -Iseconds)"'","metadata":{"bandit_version":"unknown"}}' > bandit-report.json
              # Preserve original exit code, but note JSON issue
              if [ $original_exit_code -eq 0 ]; then
                exit_code=2
              fi
            fi
            if [ $exit_code -eq 0 ]; then
              echo "âœ… Bandit scan completed, no issues found"
            elif [ $exit_code -eq 1 ]; then
              echo "âš ï¸  Bandit found issues (see bandit-report.json)"
            else
              echo "âš ï¸  Bandit check failed with exit code $exit_code (execution error - continuing)"
              if [ $exit_code -ne 2 ]; then
                echo '{"results":[],"generated_at":"'"$(date -Iseconds)"'","metadata":{"bandit_version":"unknown"}}' > bandit-report.json
              fi
            fi
          else
            echo "â„¹ï¸  Directory '$SCAN_TARGET' not found â€” skipping Bandit scan"
            echo '{"results":[],"generated_at":"'"$(date -Iseconds)"'","metadata":{"bandit_version":"unknown"}}' > bandit-report.json
            exit_code=0
          fi
          # Explicitly exit with captured exit code
          exit $exit_code
      - name: Semgrep Scan
        uses: returntocorp/semgrep-action@v1
        continue-on-error: true
        with:
          config: >-
            p/security-audit
            p/secrets
            p/owasp-top-ten
      - name: Generate SARIF report
        run: |
          # Generate SARIF report using installed semgrep
          if command -v semgrep >/dev/null 2>&1 || python -m semgrep --version >/dev/null 2>&1; then
            python -m semgrep scan \
              --sarif \
              --output=semgrep.sarif \
              --config=p/security-audit \
              --config=p/secrets \
              --config=p/owasp-top-ten \
              --timeout=300 || true
          else
            echo "âš ï¸  Semgrep not available, creating empty SARIF"
            echo '{"version": "2.1.0", "$schema": "https://raw.githubusercontent.com/oasis-tcs/sarif-spec/master/Schemata/sarif-schema-2.1.0.json", "runs": [{"results": []}]}' > semgrep.sarif
          fi
        continue-on-error: true
      - name: Semgrep CI
        run: |
          # Semgrep CI requires authentication, skip if not available
          if [ -n "${{ secrets.SEMGREP_APP_TOKEN }}" ]; then
            python -m semgrep ci --sarif --output=semgrep-ci.sarif || true
          else
            echo "âš ï¸  SEMGREP_APP_TOKEN not set, skipping Semgrep CI scan"
            echo '{"version": "2.1.0", "$schema": "https://raw.githubusercontent.com/oasis-tcs/sarif-spec/master/Schemata/sarif-schema-2.1.0.json", "runs": [{"results": []}]}' > semgrep-ci.sarif || true
          fi
        continue-on-error: true
      - name: Upload SARIF
        uses: github/codeql-action/upload-sarif@v3
        if: always() && hashFiles('semgrep.sarif') != ''
        with:
          sarif_file: semgrep.sarif
      - name: Upload security artifacts
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: security-reports-${{ github.sha }}
          path: |
            safety-report.json
            bandit-report.json
            semgrep.sarif
            semgrep-ci.sarif
          retention-days: 30
      - name: Evaluate
        id: scan-results
        run: |
          vuln=0
          crit=0
          # Initialize empty JSON files if they don't exist
          [ ! -f safety-report.json ] && echo "[]" > safety-report.json || true
          [ ! -f bandit-report.json ] && echo '{"results":[]}' > bandit-report.json || true
          # Count vulnerabilities from Safety
          if [ -s safety-report.json ]; then
            v=$(jq 'if type=="array" then length else 0 end' safety-report.json 2>/dev/null || echo 0)
            vuln=$((vuln+v))
          fi
          # Count vulnerabilities from Bandit
          if [ -s bandit-report.json ]; then
            b=$(jq '.results|length' bandit-report.json 2>/dev/null || echo 0)
            vuln=$((vuln+b))
            # Count critical/high severity issues
            crit=$(jq '[.results[] | select(.issue_severity=="HIGH" or .issue_severity=="CRITICAL")] | length' bandit-report.json 2>/dev/null || echo 0)
          fi
          echo "vulnerabilities=$vuln" >> $GITHUB_OUTPUT
          echo "critical-vulnerabilities=$crit" >> $GITHUB_OUTPUT
          echo "passed=$([ "$crit" -eq 0 ] && echo true || echo false)" >> $GITHUB_OUTPUT
          echo "ðŸ“Š Found $vuln total vulnerabilities, $crit critical"
          
          # Fail the job if critical vulnerabilities are found
          if [ "$crit" -gt 0 ]; then
            echo "âŒ Security scan FAILED: Found $crit critical vulnerabilities"
            exit 1
          elif [ "$vuln" -gt 10 ]; then
            echo "âš ï¸  Security scan WARNING: Found $vuln total vulnerabilities (threshold: 10)"
            echo "âš ï¸  Consider reviewing and fixing vulnerabilities before merging"
          else
            echo "âœ… Security scan PASSED: $vuln total vulnerabilities, $crit critical"
          fi
          
          # Additional enforcement: Check Safety for critical vulnerabilities
          if [ -s safety-report.json ]; then
            safety_critical=$(jq '[.[] | select(.severity == "CRITICAL" or .severity == "HIGH")] | length' safety-report.json 2>/dev/null || echo 0)
            if [ "$safety_critical" -gt 0 ]; then
              echo "âŒ Safety found $safety_critical critical/high severity vulnerabilities"
              exit 1
            fi
          fi
          
          # Create GitHub job summary
          echo "## ðŸ”’ Security Scan Results" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Tool | Status | Vulnerabilities | Critical |" >> $GITHUB_STEP_SUMMARY
          echo "|------|--------|-----------------|----------|" >> $GITHUB_STEP_SUMMARY
          safety_count=$(jq 'length' safety-report.json 2>/dev/null || echo 0)
          bandit_count=$(jq '.results|length' bandit-report.json 2>/dev/null || echo 0)
          echo "| Safety | $([ "$safety_count" -eq 0 ] && echo "âœ… Pass" || echo "âš ï¸ Issues") | $safety_count | - |" >> $GITHUB_STEP_SUMMARY
          echo "| Bandit | $([ "$bandit_count" -eq 0 ] && echo "âœ… Pass" || echo "âš ï¸ Issues") | $bandit_count | $crit |" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Total:** $vuln vulnerabilities, $crit critical" >> $GITHUB_STEP_SUMMARY
